# 간략한 내용 정리
## 디자인 패턴과 프레임워크
소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴이라고 합니다. 
디자인 패턴의 목적은 설계를 재사용하는 것입니다. 

디자인 패턴이 설계를 재사용하기 위함이라면, 프레임워크는 설계와 코드를 함께 재사용하기 위한 것입니다. 
프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공합니다. 

디자인 패턴과 프레임워크 모두 14장에서 살펴본 일관성있는 협력과 관련이 있습니다. 
### 디자인 패턴과 설계 재사용
#### 소프트웨어 패턴
패턴이란 무엇인가를 논의할 때면 반복적으로 언급되는 핵심적인 특징은 다음과 같습니다. 
##### 패턴을 반복적으로 발생하는 문제와 해법의 쌍으로 정의됩니다. 
##### 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있습니다. 
##### 패턴은 추상적인 원칙과 실제 코드 사이의 간극을 메워주며 실질적인 코드 작성을 돕습니다.
##### 패턴의 요점은 패턴이 실무에서 탄생했다는 점입니다. 

#### 패턴 분류
패턴을 분류하는 일반적인 방법은 패턴의 범위나 적용 단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄의 4가지로 분류하는 것입니다. 

디자인 패턴의 상위에는 소프트웨어 전체적인 구조를 결정하기 위해 사용하는 아키텍처 패턴이 위치합니다. 
아키텍처 패턴은 미리 정의된 서브시스템을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함합니다. 

디자인 패턴 하위에는 이디엄이 위치합니다. 
이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴을, 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술합니다. 
특정 언어의 패턴에 종속적이기에 다른 언어에선 무용지물이 될 수도 있습니다.

분석 패턴은 주로 도메인 내의 개념적인 문제를 해결하는데 초점을 맞춥니다. 

#### 패턴과 책임-주도 설계
객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체간의 유연한 협력 관계를 구축하는 일입니다. 
대부분은 훌륭한 품질의 설계를 얻기 위해선 많은 시간과 노력을 들여합니다.
특히 어떤 책임이 필요하며, 협력 관계 구축을 위해 객체와 객체간의 어떤 의존성이 존재하는가를 고민해봐야 합니다. 

그리고 이런 고민의 해답을 가능하게 만드는 것은 특정 상황에 적용 가능한 패턴을 잘 알고 시스템안에 구현한 객체들의 역할과 책임, 협력 관계를 구성하는 것입니다. 

패턴의 구성 요소는 클래스가 아닌 역할입니다. 
예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE패턴을 살펴보겠습니다. 

패턴의 구성요소인 Component, Composite, Leaf는 클래스가 아니라 협력에 참여하는 객체들의 역할입니다. 
여기서 Component는 역할이기에 Component가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 Component의 역할을 수행할 수 있습니다. 

역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시하기에 그림 15.2와 같이 하나의 객체가 세가지 역할 모두를 수행하더라도 문제가 없습니다. 

예를 들어, 그림 15.3은 8장에서 살펴본 중복 할인 정책을 다이어그램으로 표현한 것입니다. 
중복 할인 설계의 기본 구조는 COMPOSITE 패턴을 따릅니다. 
OverlappedDiscountPolicy는 Composite의 역할을 수행하고 AmountDiscountPolicy와 PercentDiscountPolicy가 Leaf의 역할을 수행합니다. 

여기서는 서로 다른 두 클래스인 AmountDiscountPolicy와 PercentDiscountPolicy가 동일한 Leaf라는 역할을 수행한다는 것에 주목해야 합니다. 

또한 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아닙니다. 

그림 15.2, 그림 15.3은 모두 올바른 COMPOSITE 패턴입니다. 
여기서 중요한 것은 패턴을 적용하기 위해선 패턴에서 제시하는 구조를 그대로 표현하는 것이 아니라 패턴의 기본 구조로부터 출발해 현재의 요구에 맞게 구조를 수정해야 한다는 것을 의미합니다. 

#### 캡슐화와 디자인 패턴
각 디자인 패턴은 특정한 변경을 캡슐화하기 위해 독자적인 방법을 정의합니다. 

영화 예매 시스템에선 Movie가 DiscountPolicy 상속 계층을 합성 관계로 유지해야한다는 표현을 했지만 해당 설계는 STRATEGY 패턴을 적용한 예입니다. 
STRATEGY 패턴의 목적은 알고리즘 변경을 캡슐화 하는 것이고 이를 구현하기 위해 객체 합성을 이용합니다. 

영화에 적용될 할인 정책의 종류는 Movie가 참조하는 DiscountPolicy의 서브클래스가 무엇인지에 따라 결정됩니다. 
그리고 STRATEGY 패턴을 이용하면 Movie와 DiscountPolicy 사이의 결합도를 낮게 유지할 수 있어 런타임에 알고리즘을 변경할 수 있습니다. 

반면 캡슐화를 위한 방법 중 TEMPLATE METHOD 패턴이 존재합니다. 
이는 캡슐화를 위해 합성 관계가 아닌 상속 관계를 사용한 것입니다. 
합성과는 달리 상속을 사용했기에 런타임에 알고리즘 변경을 하는 것은 어렵지만 STRATEGY 패턴보단 복잡도를 낮출 수 있는 것은 장점입니다. 

핸드폰 과금 시스템 설계는 DECORATOR 패턴을 기반으로 합니다. 
DECORATOR 패턴은 객체 행동을 동적으로 추가할 수 있게 해주는 패턴으로 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용합니다. 
DECORATOR 패턴은 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화할 수 있습니다. 

디자인 패턴에서 중요한 것은 어떤 변경을 캡슐화하는지 이해하는 것이 중요합니다. 또한 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요합니다. 
#### 패턴은 출발점이다
패턴은 출발점이며, 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반입니다. 
그렇기에 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정해야 합니다. 

패턴을 사용하면서 부딪히게 되는 대부분의 문제는 맹목적으로 사용할 때 발생합니다. 
이는 설계를 불필요하게 복잡하게 만드는 문제를 만듭니다. 

결국 패턴의 적용은 정당한 이유가 필요하며, 패턴을 적용할 땐 항상 설계를 좀 더 단순하고 명확하게 만들어야 합니다. 
만약 코드를 공유하는 사람이 패턴을 모른다면 설계에 대한 지식과 패턴에 대한 지식도 함께 공유하는 것이 필요합니다. 

조슈아 케리에브스키는 패턴을 가장 효율적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것입니다. 

패턴은 공통적인 문제에 적절한 해법은 제공하지만 공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수 있음으로, 문제를 분석하고 창의력을 발휘해 패턴을 현재 문제에 적합하게 수정해야 합니다. 
### 프레임워크와 코드 재사용
#### 코드 재사용 대 설계 재사용
디자인 패턴은 프로그래밍 언어에 독립적으로 재사용 가능한 설계 아이디어를 제공하는 것을 목적으로 합니다. 
그래서 디자인 패턴을 적용하기 위해선 설계 아이디어를 프로그래밍 언어에 특성에 맞춰 재작성해야 한다는 단점이 있습니다. 

가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것입니다. 
그리고 이러한 형태를 띄는 것이 바로 프레임워크입니다. 

프레임워크란 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호 작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계, 또는 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징 할 수 있는 애플리케이션 골격을 말합니다. 
#### 상위 정책과 하위 정책으로 패키지 분리하기
프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화라고 할 수 있으며, 이러한 특징이 프레임워크의 재사용성을 향상시키는 이유는 일관성있는 협력에 있습니다. 

협력은 일관성있고 유연하게 만들기위해 추상화를 이용해 변경을 캡슐화해야 합니다. 
그리고 협력을 구현하는 코드안의 의존성은 가급적이면 추상 클래스나 같은 추상화를 향하도록 작성해야 합니다. 

전통적인 소프트웨어 개발 방법의 경우 상위 정책이 세부적인 사항에 의존하도록 소프트웨어를 구성합니다.
그런데 전통적인 방식은 변하지 않는 부분이 변하는 부분을 의존하게 만들어 변경에 대한 파급효과가 크다는 단점이 있습니다.

그래서 이러한 문제를 해결하기 위해 의존성 역전 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존하도록 만드는 것이 가장 좋은 방법이 됩니다. 
이렇게 만들었을 때 동일한 역할을 수행하는 객체들 사이의 협력 구조를 다양한 애플리케이션 안에서 재사용할 수 있게 됩니다. 
#### 제어 역전 원리
로버트 마틴은 객체지향 설계는 의존성이 역전된 설계라는 점을 강조합니다. 
의존성 역전 원리는 프레임워크의 가장 기본적인 설계 매커니즘이며, 의존성의 방향뿐 아니라 제어 흐름의 주체 역시 역전시킵니다.

프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동됩니다. 
그렇기에 우리의 코드는 수동적인 존재가 될 수 밖에 없지만 이러한 제어의 역전이 프레임워크의 핵심 개념이자 코드 재사용을 가능하게 만들어줍니다.
# 읽고 느낀 점
#### 객체 지향
흔히 웹개발에선 객체 지향적으로 설계하고 애플리케이션을 만들라고 합니다. 
그렇기에 저는 너무 당연하게 Framwork를 사용해 기능을 구현했습니다.
시간이 지나 Framework를 묻는 누군가가 생긴다면 객체 지향적인 개발을 위해선 Framework로 구현하는것이 좋다고 했습니다.

하지만 왜 Framework를 사용해서 개발하는 것이 객체지향적인지 또 왜 객체 지향적으로 개발해야하는지를 설명하지 못했습니다. 
그리고 왜를 생각할 수 없었던 것은 **너무 당연**했기 때문이었습니다.

이따금씩 Framework를 사용하는 것은 너무 복잡하고 애플리케이션을 무겁게 만든다는 생각도 했던것 같습니다. 
하지만 Spring 강의, 객체 지향의 사실과 오해, Object를 읽으며 너무 당연하게 여겨왔던 혹은 오해했던 제 생각이 잘못되었다는 것을 느낄 수 있었습니다. 

여전히 왜 객체 지향적으로 개발을 한다는 것에 모든 설명을 할 순 없지만 그럼에도 불구하고 설명을 해야한다면 **오랜 개발 선배님들의 노하우**가 녹아있기 때문이라고 말하고 싶습니다. 

그리고 제가 생각한 그 노하우의 핵심 원칙은 **리스코프 치환 원칙**이라고 생각합니다. 
여러 원칙이 있었지만 **리스코프 치환 원칙**을 선택한 것은 **다형성**입니다. 
**다형성**이란 어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 것을 말합니다. 

리스코프 치환 원칙은 자식 객체가 부모 객체를 완벽히 대체할 수 있게 만들어줍니다. 
이런 다형적 특징을 통해 설계의 유연함을 가질 수 있게 되고, 그러한 설계의 유연함을 통해 **변하는 부분**과 **변하지 않는 부분**을 분리함으로써 변경이 용이한 안정적인 시스템으로 만들어 줍니다. 

결국 제가 생각한 객체 지향적 개발을 하는 이유는 **유연함**, **안정성**입니다. 
이 부분을 높게 본 이유는 현장에서 너무 다양한 이유로 기존의 기능이 변경될 수도 있고 아예 없어져 버리기도 하기 때문입니다. 
 




