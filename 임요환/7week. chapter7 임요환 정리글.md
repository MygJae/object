# 간략한 내용 정리

# 7 객체 분해
- 문제를 해결하기 위해서는 장기 기억(long-term memory)을 단기 기억(short-term memory)으로 불러와야 되고 단기 기억의 용량이 초과하는 순간 문제 해결 능력이 급격하게 떨어지게 되는데 이를 인지 과부화(cognitive overload)라고 함
- 단기 기억에 본질적인 정보만 남기기 위해 하는 작업을 추상화라고 함
- 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 분해(decomposition)라고 함
- 추상화들을 더 큰 규모의 추상화로 압축시키며 단기 기억의 한계를 초월할 수 있음

## 7-1 프로시저 추상화와 데이터 추상화
- 프로시저 추상화 = 소프트웨어가 무엇을 해야 하는지
    - 기능 분해(functional decompositon) = 알고리즘 분해(algorithmic decomposition)
- 데이터 추상화 = 소프트웨어가 무엇을 알아야 하는지
    - 데이터 중심의 타입 추상화(type abstraction) = 추상 데이터 타입(abstract data type)
    - 데이터 중심의 프로시저 추상화(procedure abstraction) = 객체지향(object-oriented)

## 7-2 프로시저 추상화와 기능 분해
### 메인 함수로서의 시스템
- 프로시저 = 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 잇는 추상화 방법
- 프로시저 중심의 기능 분해 관점에서 시스템은 수학의 함수와 동일함
- 정통적인 기능 분해 방법은 하향식 접근법(Top-Down Approach)을 따름
- 하향식 접근법 = 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고 이 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법, 하위 기능은 상위 기능보다 덜 추상적이어야 함(더 구체적이어야 함)

### 급여 관리 시스템
- 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것임 -> 책의 목차를 정리하고 내용을 채워 넣는 것과 유사함
- 기능 분해 방법은 기능을 중심으로 필요한 데이터를 결정함(주연 = 기능, 조연 = 데이터)

### 급여 관리 시스템 구현
- 하향식 기능 분해 방식은 메인 함수를 루트로 하는 트리(tree)로 표현할 수 있음
- 하향식 기능 분해 방식은 논리적이고 체계적인 시스템 개발 절차를 제시함

### 하향식 기능 분해의 문제점
- 변경에 취약한 설계를 낳는다는 것

#### 하나의 메인 함수라는 비현실적인 아이디어
- 대부분의 시스템에서 하나의 메인 기능이라는 개념은 존재하지 않으며 모든 기능들은 기능성의 측면에서는 동등하고 독립적이고 완결된 하나의 기능으로 표현함
- 하향식 접근법은 하나의 알고리즘을 구현하거나 배치 처리를 구현하기에는 적합하지만 상호작용 시스템을 개발하는 데는 적합하지 않음

#### 메인 함수의 빈번한 재설계
- 하향식 기능 분해는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 함
- 기존 코드를 수정하는 것은 버그를 만들어낼 확률을 높임

#### 비즈니스 로직과 사용자 인터페이스의 결합
- 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합됨
- 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도는 다름
- 하향식 기능 분해는 관심사의 분리라는 아키텍처 설계의 목적을 달성하기 어려움

#### 성급하게 결정된 실행 순서
- 설계 시점에 시스템이 무엇을 해야 하는지가 아니라 어떻게 동작해야 하는지에 집중하도록 만듬
- 하향식 접근법은 함수들의 실행 순서를 정의하는 시간 제약을 강조함
- 분해한 함수들을 재사용하기도 어려움
- 하향식 설계의 모든 문제의 원인은 결합도임

#### 데이터 변경으로 인한 파급효과
- 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어려움 -> 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어려움
- 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함꼐 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 함
- 기능 분해의 문제를 해결하기 위해 정보 은니과 모듈이라는 개념을 제시함

### 언제 하향식 분해가 유용한가?
- 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이함
- 하나의 함수에 제어가 집중되기 때문에 확장하기 어려움
- 하향식 설계는 본질적인 측면보다 사용자 인터페이스 같은 비본질적인 측면을 집중하게 만듬
- 과도하게 함수에 집중함으로써 데이터에 대한 영향도를 파악하기 어려움
- 재사용하기 어려움

## 7-3 모듈
### 정보 은닉과 모듈
- 기능을 기반으로 시스템을 분리하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것
- 모듈은 책임의 할당임
- 정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리임
- 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고 잘 정의되고 쉽게 변경되지 않은 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 함
- 모듈은 복잡성과 변경 가능성을 감춰야함

### 모듈의 장점과 한계
- 장점
    - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미침
    - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리함
    - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지함
- 한계
    - 모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만 태생적으로 변경을 관리하기 위한 구현 기법이기 때문에 추상화 관점에서의 한계점이 명확함
    - 가장 큰 단점은 인스턴스의 개념을 제공하지 않음

## 7-4 데이터 추상화와 추상 데이터 타입
### 추상 데이터 타입
- 타입 = 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미함
- 데이터 추상화 = 프로시저 추상화를 보안하기 위한 개념
- 추상 데이터 타입 구현을 위한 프로그래밍 언어의 지원 요소
    - 타입 정의를 선언할 수 있어야 함
    - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 함
    - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 함
    - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 함
- 추상 데이터 타입은 추상화 수준을 향상시킴
- 추상 데이터 타입 정의를 기반으로 객체를 생성하는 것이 가능하지만 여전히 데이터와 기능을 분리해서 바라본다는 점에 주의해야 함 -> 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있음

## 7-5 클래스
### 클래스는 추상 데이터 타입인가?
- 클래스와 추상 데이터 타입 모두 외부에서는 객체 내부 속성에 직접 접근할 수 없으며 퍼블릭 인터페이스를 통해서만 외부와 의사소통할 수 있음
- 그러나 두 개의 핵심적인 차이는 클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다는 점임
- 상속과 다형성을 지원하면 객체지향 프로그래밍(Object-Oriented Programming), 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍은 객체기반 프로그래밍(Object-Based Programming)
- 추상 데이터 타입은 타입을 추상화한 것(type abstraction), 클래스는 절차를 추상화한 것(procedural abstraction)
- 추상 데이터 타입은 오퍼레이션을 기준으로 타입을 통합함, 오퍼레이션을 기준으로 타입들을 추상화함
- 객체지향은 타입을 기준으로 오퍼레이션을 묶음, 타입을 기준으로 절차들을 추상화함

### 추상 데이터 타입에서 클래스로 변경하기
- Employee라는 직원 클래스를 만들어 공통적인 것을 묶고 SalariedEmploy(정규직)와 HourlyEmployee(알바)는 Employee를 상속하여 클래스로 구현함

### 변경을 기준으로 선택하라
- 클래스를 사용하더라도 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아님
- 객체지향에서 타입 변수를 이용한 조건문을 다형성으로 대체함
- 객체가 메시지를 처리할 적절한 메서드를 선택함
- 개방-폐쇄 원칙(Open-Closed Principle, OCP) = 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성
- 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정됨
- 새로운 타입을 빈번하게 추가해야 하면 객체지향의 클래스 구조가 더 유리하고 새로운 오퍼레이션을 빈전하게 추가해야 한다면 추상 데이터 타입을 선택하는 것이 현명한 판단임
- 추상 데이터 타입의 접근법을 객체지향 설계에 구현한 것을 데이터 주도 설계라고 부름

### 협력이 중요하다
- 객체지향에서 중요한 것은 역할, 책임, 협력임
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오펴레이션의 구현 방식을 타입별로 분배하는 것은 올바른 접근법이 아님

# 읽고 느낀 점
- 이번 장은 프로그래밍의 역사에 대해 알아볼 수 있었던 장이였던 것 같다
- 절차지향에서 객체지향까지 넘어오는 과정에 대해 예제 코드와 함께 알아볼 수 있어서 이해가 잘되었다
- 내가 예전에 개발하던 방식은 추상 데이터 타입과 비슷하단 것을 알았고 이는 데이터 주도 설계로 이어진다는 것도 알게되었다
- 어쩌면 SI에서는 기존 오퍼레이션의 수정이 아닌 추가를 지속적으로 하는 작업이 더 많기 때문에 추상 데이터 타입 접근법이 더 나을 수도 있겠다는 생각이 들었다