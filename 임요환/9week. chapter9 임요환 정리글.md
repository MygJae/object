# 간략한 내용 정리

# 9 유연한 설계
- 기법들의 원칙이라는 관점에서 정리하는 챕터

## 9-1 개방-폐쇄 원칙
- 개방-폐쇄 원칙(Open-Closed Principle, OCP) = 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 함
- 핵심 키워드는 `확장`과 `수정`임
    - 확장에 대해 열려 있다 = 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 `동작`을 추가해서 애플리케이션의 기능을 확장할 수 있음
    - 수정에 대해 닫혀 있다 = 기존의 `코드`를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있음
- 코드를 수정하지 않고도 애플리케이션의 동작을 확잘할 수 있는 설계를 유연한 설계라고 말함

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
- OCP는 런타임 의존성과 컴파일타임 의존성에 관한 이야기임
- 런타임 의존성 = 객체들의 관계
- 컴파일 의존성 = 클래스들의 관계
- 컴파일타임의 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조

### 추상화가 핵심이다
- OCP의 핵심은 추상화에 의존하는 것임
- 추상화 = 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법
- 추상화 부분은 수정에 닫혀있어야 하며 추상화를 통해 생략된 부분은 확장의 여지를 남김
- 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장 가능함

## 9-2 생성 사용 분리
- 결합도가 높아지면 OCP를 따르는 구조를 설계하기 어려움
- 유연하고 재사용 가능한 설계를 위해 객체와 관련된 두가지 책임을 서로 다른 객체로 분리해야 함
- 객체에 대한 생성과 사용을 분리(separating use from creation)해야 함
- 사용으로 생성을 분리하는 보편적인 방법 = 객체를 생성하는 책임을 클라이언트로 옮기는 것

### FACTORY 추가하기
- 위의 객체 생성의 책임을 클라이언트로 옮겼지만 이는 클라이언트가 특정 컨텍스트에 묶여도 상관 없다는 전제이고 만약 묶이지 않아야 한다면 어떻게 해야 될까?
- FACTORY = 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체
- FACTORY를 사용하여 객체 생성의 책임을 모두 FACTORY로 이동시키므로 클라이언트는 오직 사용과 관련된 책임만 지고 생성과 관련된 어떤 지식도 가지지 않아도 됨

### 순수한 가공물에게 책임 할당하기
- 책임 할당의 가장 기본 원칙은 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 INFORMATION EXPERT에게 책임을 할당하는 것임
- FACTORY는 도메인 모델에 속하지 않고 순수하게 기술적인 결정임 -> 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을 도메인과 아무런 상관이 없는 가공의 객체로 이동시킨 것
- 행위적 분해(behavioral decomposition)
- 표현적 분해(representational decomposition)
    - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것
    - 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것이 목적임
    - 객체지향 설계를 위한 가장 기본적인 접근법
- PURE FABRICATION(순수한 가공물) = 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체, 표현적 분해보다는 행위적 분해에 의해 생성되는 것이 일반적임
- 어떤 행위에 대해 책임질 마땅한 도메인 개념이 존재하지 않으면 PURE FABRICATION을 생성하고 객체에게 책임을 할당해라
- FACTORY는 객체의 생성 책임을 할당할만한 도메인 객체가 존재하지 않을 때 선택할 수 있는 PURE FABRICATION임

## 9-3 의존성 주입
- 의존성 주입(Dependency Injection) = 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
- 의존성 주입은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법임
- 의존성 주입 세가지 방법
    - 생성자 주입(constructor injection) = 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    - setter 주입(setter injection) = 객체 생성 후 setter 메서드를 통한 의존성 해결
        - 런타임에 의존성 대상 변경 가능
        - 어떤 의존성이 필수적인지 명시적으로 표현할 수 없으며 객체가 생성된 후 호출돼야 함 -> 비정상적인 상태에서 에러 발생 여지 있음
    - 메서드 주입(method injection) = 메서드 실행 시 인자를 이용한 의존성 해결
        - 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현 가능

### 숨겨진 의존성은 나쁘다
- SERVICE LOCATOR = 의존성을 해결할 객체들을 보관하는 저장소
- SERVICE LOCATOR 패턴 = 서비스를 사용하는 코드로부터 서비스가 누구인지(구현체의 타입), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해줌
- 의존성을 숨기는 단점이 있음 -> 컴파일 시점이 아닌 런타임 시점에 에러가 발생됨
- 숨겨진 의존성은 단위 테스트 작성도 어려움 -> 테스트 고립을 위반하기 쉬움
- SERVICE LOCATOR는 캡슐화를 위반하게 됨
- 명시적 의존성이 숨겨진 의존성보다 좋음

## 9-4 의존성 역전 원칙
### 추상화와 의존성 역전
- 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준이 영향을 받게 됨
- 상위 수준 클래스, 하위 수준 클래스 모두 추상화에 의존하게 되면 하위 수준의 클래스의 변경으로 인해 상위 수준의 클래스가 영향을 받는 것을 방지할 수 있음
- 상위 수준을 재사용할 떄 하위 수준 클래스에 얽매이지 않고 다양한 컨텍스트에서 재사용이 가능함
- 의존성 역전 원칙(Dependency Inversion Principle, DIP)
    - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안됨. 둘다 추상화에 의존해야 함
    - 추상화는 구체적인 사항에 의존해서는 안됨, 구체적인 사항은 추상화에 의존해야 함

### 의존성 역전 원칙과 패키지
- 불필요한 클래스들을 같은 패키지에 두면 전체적인 빌드 시간이 가파르게 상승함
- SEPARATED INTERFACE 패턴 = 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시키고 함꼐 사용될 필요가 없는 클래스들을 별도의 독립적인 패키지에 모으는 것
- DIP를 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 함

## 9-5 유연성에 대한 조언
### 유연한 설계는 유연성이 필요할 때만 옳다
- 항상 유연한 설계가 좋은 것은 아니며 단순하고 명확한 구조가 좋을 떄도 있음
- 불필요한 유연성은 불필요한 복잡성을 생성함

### 협력과 책임이 중요하다
- 설계를 유연하게 만들기 위해서는 역할, 책임, 협력에 초점을 맞춰야 함
- 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선임
- 객체를 생성하는 방법을 생각하기 전에 시스템에 필요한 책임들에 대해 먼저 생각하자
- 역할, 책임, 협력이 잘 설계되지 않으면 의존성 관리는 물거품이 될 가능성이 높음

# 읽고 느낀 점
- 애매하게 알고 있던 SOLID 패턴들에 대해 확실하게 개념부터 알아가는거 같다
- 인터페이스의 소유권까지 역전시키는 법을 적용한 방법이 조금 색다르게 느껴졌다
- 런타임 의존성과 컴파일타임 의존성에 대해 다시 한번 복습하는 계기가 된 것 같다