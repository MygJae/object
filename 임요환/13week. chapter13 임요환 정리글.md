# 간략한 내용 정리

# 13 서브클래싱과 서브타이핑
- 상속의 두 가지 용도
    - 타입 계층을 구현 = 부모클래스는 일반적인 개념을 구현(일반화, generalization)하고 자식 클래스는 특수한 개념을 구현(특수화, specialization)함
    - 코드 재사용 -> 높은 결합도와 변경하기 어려운 코드

## 13-1 타입
### 개념 관점의 타입
- 우리가 인지하는 세상의 사물의 종류
- 우리가 인삭하는 객체들에 적용하는 개념이나 아이디어
- 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스(instance)라고 부름
- 타입의 인스턴스 = 객체
- 타입의 세가지 구성요소
    - 심볼(symbol) = 타입에 이름을 붙인 것
    - 내연(intension) = 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동
    - 외연(extension) = 타입에 속하는 객체들의 집합

### 프로그래밍 언어 관점의 타입
- 연속적인 비트에 의미와 제약을 부여하기 위해 사용
- 프로그래밍 언어에서 타입의 두가지 목적
    - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의함
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공함
- 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용

### 객체지향 패러다임 관점의 타입
- 타입을 정의하는 것 = 퍼블릭 인터페이스(객체가 수신할 수 있는 메시지의 집합)를 정의하는 것
- 객체의 중요한 것은 속성이 아니라 행동임

## 13-2 타입 계층
### 타입 사이의 포함관계
- 슈퍼타입(supertype) 
    - 일반적인 타입
    - 집합이 다른 집합의 모든 멤버르르 포함함
    - 타입 저으이가 다른 타입보다 좀 더 일반적임
- 서브타입(subtype)
    - 더 특수한 타입
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함됨
    - 타입 정의가 다른 타입보다 좀 더 구체적임
- 일반화
    - 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정
    - 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과
- 특수화
    - 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정
    - 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과

### 객체지향 프로그래밍과 타입 계층
- 퍼블릭 인터페이스 관점의 슈퍼타입과 서브타입
    - 슈퍼타입 = 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
    - 서브타입 = 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것
- 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준은 퍼블릭 인터페이스임

## 13-3 서브클래싱과 서브타이핑
### 언제 상속을 사용해야 하는가?
- 마틴 오더스키의 두 조건
    - 상속 관계가 is-a 관계를 모델링하는가?
    - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
- 상속 적용 여부는 두 번쨰 질문에 초점을 맞추는 것이 더 중요함

### is-a 관계
- 새는 날 수 있다, 펭귄은 새다, 하지만 펭귄은 날 수 없다 -> 펭귄은 새의 서브타입이 될 수 없음
- 새에 날 수 있따라는 행동이 포함되지 않는다면 펭귄은 새의 서브타입이 될수 있음 -> 어휘적인 관점과 행동 관점이 일치하게 됨
- 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요함

### 행동 호환성
- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점임
- 클라이언트가 모든 새는 날 수 있다고 가정하면 펭귄과 새는 올바른 타입 계층을 구성한다고 할 수 없음
- 상속 관계를 유지하며 문제를 해결하기 위한 세가지 시도
    - 새의 fly 메서드를 오버라이딩해서 비워둠 -> 날 수 있다는 기대를 만족시키지 못하므로 올바른 설계라고 볼 수 없음
    - 새의 fly 메서드를 오버라이딩해서 예외를 던짐 -> 이 방법 역시 클라이언트의 관점에서 새와 펭귄의 행동이 호환되지 않음
    - flyBird 메서드를 수정해서 인자로 전달된 새의 타입이 펭귄이 아닐 경우에만 fly 메서드를 전송함 -> 펭귄 이외에 또 다른 날 수 없는 새가 추가되면 계속해서 분기처리하는 코드가 추가됨

### 클라이언트의 기대에 따라 계층 분리하기
- 날 수 있는 새와 날 수 없는 새를 명확하게 구분하여 상속 계층을 분리함
- 클라이언트에 따라 인터페이스를 분리함 -> 변경에 대한 영향을 더 세밀하게 제어 가능
- 합성을 사용함
- 불안정한 상속 계층을 계속 가지고 가는 것 보다 재사용 가능하도록 수정하는 것이 더 좋은 방법임
- 인터페이스 분리 원칙(Interface Segregation Principle) = 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙
- 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중해야 함

### 서브클래싱과 서브타이핑
- 상속을 사용하는 두 가지 목적
    - 서브클래싱
        - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
        - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없음
        - 서브클래싱을 구현상속(implementation inheritance) 또는 클래스 상속(class inheritance)이라고 부름
    - 서브타이핑
        - 타입 계층을 구성하기 위해 상속을 사용하는 경우
        - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있음
        - 서브타이핑을 인터페이스 상속(interface inheritance)이라고 부름
- 서브타입의 퍼블릭 인터페이스가 슈퍼타입과 동일하거나 더 많은 오퍼레이션을 포함해야 슈퍼타입 대신 사용할 수 있음
- 서브타이핑 관계를 유지하기 위해서는 모든 행동을 동일하게 할 수 있어야 함 -> 행동 호환성(behavioral substitution)을 만족시켜야 함
- 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성(substitutability)를 포함함

## 13-4 리스코프 치환 원칙
- S형의 각 객체 o1에 ㄷ해ㅐ T형의 객체 o2가 있고 T에 의해 정의된 모드느 프로그램 P에서 T가 S로 치환될 때 P의 동작이 변하지 않으면 S는 T의 서브타입임
- 리스코프 치환 원칙(Liskov Substitution Principle) = 서브타입은 그것의 기반 타입에 대해 대체 가능해야 함, 서브타이핑

### 클라이언트와 대체 가능성
- 어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능함
- 상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바름
- 대체 가능성을 결정하는 것은 클라이언트임

### is-a 관계 다시 살펴보기
- 클라이언트를 고려하지 않은 채 개념과 속성의 측면에서 상속 관계를 정할 경우 리스코프 치환 원칙을 위반하는 서브클래싱에 이르게 될 확률이 높음
- 행동을 공유하지 않은 두 타입의 이름이 단순히 is-a로 연결 가능하다고 해서 상속 관계로 연결하지 마라
- 객체지향의 대부분 규칙에서 이름이 아니라 행동이 먼저임

### 리스코프 치환 원칙은 유연한 설계의 기반이다
- 리스코프 치환 원칙은 유연한 설계 뿐만 아니라 확장성이 높음
- 리스코프 치환 원칙은 개방-폐쇄 원칙을 만족하는 설계를 위한 전제 조건이며 리스코프 치환 원칙의 위반은 잠재적인 개방-폐쇄 원칙 위반임

### 타입 계층과 리스코프 치환 원칙
- 상속이 아닌 다른 방법을 이용하더라도 클라이언트의 관점에서 서로 다른 구성 요소를 동일하게 다뤄야한다면 서브타이핑 관계의 제약을 고려해서 리스코프 치환 원칙을 준수 해야함

## 13-5 계약에 의한 설계와 서브타이핑
- 계약에 의한 설계(Design By Contract, DBC)
    - 클라이언트와 서버 사이의 협력을 의무(obligation)와 이익(benefit)으로 구성된 계약의 관점에서 표현하는 것
    - 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 사전조건(precondition)과 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 사후조건(postcondition), 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 클래스 불변식(class invariant)의 세 가지 요소로 구성됨
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 함

### 서브타입과 계약
- 계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것임
- 서브타입에 더 강력한 사전조건을 정의할 수 없음
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있음
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있음
- 서브타입에 더 약한 사후조건을 정의할 수 없음

# 읽고 느낀 점
- 그 동안 알고 있었던 SOLID 원칙 중 일부를 다시 공부하는 기분이 들었고 각각의 애매했던 특징들이나 추구하는 목적을 확실하게 알게되었다
- 객체지향은 행동이 중심이 된다는 것을 다시 알게되는 챕터였다