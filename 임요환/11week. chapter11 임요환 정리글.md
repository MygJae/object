# 간략한 내용 정리
# 11 합성과 유연한 설계
- 상속
    - is-a 관계
    - 의존성이 컴파일 타임에 해결됨
    - 클래스 사이의 정적인 관계
    - 화이트 박스 재사용 = 서브클래싱에 의한 재사용
- 합성
    - has-a 관계
    - 의존성이 런타임에 해결됨
    - 객체 사이의 동적인 관계
    - 블랙박스 재사용 = 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용

## 11-1 상속을 합성으로 변경하기
### 불필요한 인터페이스 상속 문제: java.util.Properties와 java.util.Stack
- 합성을 통해 불필요한 오퍼레이션들이 퍼블릭 이터페이스에 스며드는 것을 방지함

### 메서드 오버라이딩의 오작용 문제: InstrumentedHashSet
- 포워딩(forwarding) = 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결함 없이 일부 작동 방식을 변경하고 싶은 경우 사용하는 기법

### 부모 클래스와 자식 클래스의 동시 수정 문제: PersonalPlaylist
- 위 문제는 합성으로도 해결이 가능하진 않지만 합성을 사용하면 향후 내부 구현을 변경하더라도 파급효과를 최대한 내부로 캡슐화 할 수 있음
- 몽키 패치(Monkey Patch) = 현재 실행 중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것
- 합성은 안정성과 유연성을 제공함

## 11-2 상속으로 인한 조합의 폭발적인 증가
- 합성을 사용하여 해결하는 두가지 문제
    - 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함
    - 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어마

### 기본 정책과 부가 정책 조합하기
- 기본 정책과 부가 정책의 조합의 수가 많아지는데 이를 수용할 수 있도록 합성을 사용하요 유연하게 설계해야 함

### 상속을 이용해서 기본 정책 구현하기
### 기본 정책에 세금 정책 조합하기
- super를 사용하면 부모 클래스 사이의 결합도가 높으지므로 자식 클래스에서 부모 클래스의 메서드를 호출하지 못하도록 추상 메서드를 제공하면 클래스 결합도를 낮출 수 있음
- 훅 메서드(hook method) = 편의를 위해 기본 구현을 제공하는 메서드
- 자바는 단일 상속만 지원하기 때문에 상속으로 인해 발생하는 중복 코드 문제를 해결하기 쉽지 않음

### 기본 정책에 기본 요금 할인 정책 조합하기
### 중복 코드의 덫에 걸리다
- 상속은 상속 계층 코드가 복잡해지며 새로운 정책을 추가하기 어렵게 됨
- 클래스 폭발(class explosion) = 조합의 폭발(combinational explosion) = 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우
- 부모와 자식이 강하게 결합되며 컴파일 타임에 두 관계를 변경할 수 없기 때문임 -> 조합에 따라 조합의 수만큼 클래스를 만들어야 함

## 11-3 합성 관계로 변경하기
- 컴파일타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복잡도가 상상하며 코드를 이해하기가 어려워짐
- 설계는 변경과 유지보수를 위해 존재함

### 기본 정책 합성하기
- Rate 내부에 RatePolicy에 대한 참조자가 포함되어 있음 = 합성

### 부가 정책 적용하기
### 기본 정책과 부가 정책 합성하기
- 상속보다 설계가 복잡하고 정해진 규칙에 따라 객체를 생성하고 조합해야 하기 때문에 처음에는 코드를 이햏기 어려울 수 있지만 익숙해지면 객체를 조합하고 사용하는 방식이 더 예측 가능하고 일관성있다는 사실을 알게 될 것임

### 새로운 정책 추가하기
- 상속은 새로운 정책을 추가할 때마다 엄청나게 많은 클래스가 생긴것과는 달리 합성은 생성하고자하는 클래스만 추가하면 됨
- 또한 변경할 떄에도 해당 정책만 수정하면됨
- 단일 책임 원칙을 준수하고 있음

### 객체 합성이 클래스 상속보다 더 좋은 방법이다
- 상속은 구현을 재사용하며 합성은 객체의 인터페이스를 재사용함
- 상속은 인터페이스 상속과 구현 상속 두가지로 나뉘며 상속에 대한 모든 단점들은 구현 상속에 국한된 것임

## 11-4 믹스인
- 믹스인(mixin)
    - 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법
    - 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법
    - 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법

### 기본 정책 구현하기
### 트레이트로 부가 정책 구현하기
- 상속은 정적이지만 믹스인은 동적임
- 스칼라의 트레이트는 super 참조가 동적으로 결정됨

### 부가 정책 트레이트 믹스인하기
- 믹스인은 재사용 가능한 코드를 독립적으로 작성한 후 필요한 곳에서 쉽게 조합할 수 있게 해줌
- 믹스인도 클래스 폭발같은 문제점이 늘어날 수 있지만 중복 코드는 늘어나지 않음

### 쌓을 수 있는 변경
- 믹스인을 추상 서브클래스(abstract subclass)라고 부르기도 함
- 쌓을 수 있는 변경(stackable modification) = 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례로 추가할 수 있음

# 읽고 느낀 점
- 상속의 단점에 대해 합성의 장점에 대해 다시 한번 생각할 수 있었다
- 상속의 종류로 구현 상속과 인터페이스 상속에 관해 나왔는데 인터페이스 상속에는 어떠한 이점이 있는지 뒤의 책 내용이 궁금해졌다
- 믹스인에 대해서 처음 접해보았고 재미있는 방법인것 같았다
- 자바에서 사용하는 예제는 없는지도 한번 찾아봐야할 것 같다(트레이트같은 것이 있을까?)