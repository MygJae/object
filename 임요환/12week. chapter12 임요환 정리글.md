# 간략한 내용 정리

# 12 다형성
- 상속의 목적은 코드 재사용이 아니라 타입 계층을 구조화하기 위해 사용해야 함
- 다형성은 런타임에 메시지를 처리하기 위해 메서드를 동적으로 탐색하는 과정을 통해 구현됨 -> 상속은 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법임

## 12-1 다형성
- 다형성(Polymorphism)
    - 많은 형태를 가질 수 있는 능력
    - 하나의 추상 인터페이스에 대해 코드를 작성하고 이에 대해 서로 다른 구현을 연결할 수 있는 능력
    - 여러 타입을 대상으로 동작할 수 있는 코드를 작성하는 방법
    - 유니버설(Universal) 다형성
        - 매개변수(Parametric) 다형성 = 제네릭 프로그래밍과 관련이 높으며 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임이의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식(자바의 제네릭)
        - 포함(Inclusion) 다형성 = 서브타입(Subtype) 다형성 = 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력(객체지향 프로그래밍의 가정 널리 알려진 다형성의 형태)
    - 임시(AdHoc) 다형성
        - 오버로딩(Overloading) 다형성 = 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
        - 강제(Coercion) 다형성 = 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 타입에 사용할 수 있는 방식(ex '+' 연산자는 숫자끼리 만나면 더하고 문자열과 숫자가 만나면 문자열로 더해짐)

## 12-2 상속의 양면성
- 객체지향 프로그램은 데이터와 행동 두 가지 관점을 함께 고려해야 함
- 상속의 목적은 코드 재사용이 아니며 상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것임

### 상속을 사용한 강의 평가
- 부모 클래스와 자식 클래스에 동일한 시그니처의 메서드가 존재하면 자식 클래스의 메서드가 우선순위가 높으며 우선순위가 높다는 것은 메시지를 수신했을 때 해당 메서드가 실행된다는 것을 의미함 -> 메서드 오버라이딩
- 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것 -> 메서드 오버로딩

### 데이터 관점의 상속
- 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것
- 자식클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 됨

### 행동 관점의 상속
- 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미함
- 객체의 경우 서로 다른 상태를 저장하기 위해 각 인스턴스별 독립적인 메모리를 할당받지만 메서드의 경우 동일한 클래스의 인스턴스끼리 공유가 가능하기 때문에 한 번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게하는게 경제적임

## 12-3 업캐스팅과 동적 바인딩
### 같은 메시지, 다른 메서드
- 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 업캐스팅과 동적 바인딩이라는 메커니즘이 작용하기 때문임
- 업캐스팅 = 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것
- 동적 바인딩 = 선언된 변수의 타입이 아니라 메시지를 수신하는 객체에 따라 실행되는 메서드가 결정됨
- 개방-폐쇄 원칙이라는 목적을 이룰 수 있음

### 업캐스팅
- 상속을 이용하면 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지기 떄문에 부모 클래스의 인스턴스에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송할 수 있음
- 컴파일러는 명시적인 타입 변환 없이 자식 클래스가 부모 클래스를 대체할 수 있게 허용함
- 다운캐스팅(downcasting) = 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위한 명시적인 타입 캐스팅

### 동적 바인딩
- 정적 바인딩(static binding) = 초기 바인딩(early binding) = 컴파일타임 바인딩(compile-time binding) = 컴파일러 타임에 호출할 함수를 결정하는 방식
- 동적 바인딩(dynamic binding) = 지연 바인딩(late binding) = 실행될 메서드를 런타임에 결정하는 방식

## 12-4 동적 메서드 탐색과 다형성
- 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한 후 존재하면 메서드를 실행하고 탐색을 종료함
- 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속하며 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속됨
- 상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단함
- 객체 메시지 수신 -> 컴파일러가 self 참조라는 임시 변수를 생성한 후 메시지를 수신한 객체를 가리키도록 설정 -> self가 가르키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 동적 메서드 탐색이 이뤄짐 -> 메서드 탐색이 종료되는 순간 self 참조는 자동으로 소멸
- self 참조는 자바에서 this라고 부름
- 동적 메서드 탐색의 두가지 원리
    - 자동적인 메시지 위임 = 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받을 시 상속 계층에 따라 부모 클래스에게 처리를 위임함
    - 동적인 문맥 사용 = 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행시점에 이뤄지며 메서드를 탐색하는 경로는 self 참조를 이용해서 결정함

### 자동적인 메시지 위임
- 상속 계층은 메시지를 수신한 객체가 자신이 이해할 수 없는 메시지를 부모 클래스에게 전달하기 위한 물리적인 경로를 정의한 것으로 볼 수 있음
- 메서드 오버라이딩 = 자식 클래스의 메서드가 동일한 시그니처를 가진 부모 클래스의 메서드보다 먼저 탐색되기 때문에 벌어지는 현상
- 메서드 오버로딩 = 메서드의 이름만 같고 시그니처가 동일하지 않은 메서드들은 상속 계층에 걸쳐 공존함
- 이름 숨기기(name hiding) = 상속 계층 안에서 동일한 이름을 가진 메서드가 공존해서 발생하는 혼란을 방지하기 위해 부모 클래스에 선언된 이름이 동일한 메서드 전체를 숨겨서 클라이언트가 호출하지 못하도록 막음

### 동적인 문맥
- 동적 문맥을 결정하는 것은 메시지를 수신한 객체를 가르키는 self 참조임
- self 전송 = self 참조가 가리키는 자기 자신에게 메시지를 전송하는 것
- self 전송이 깊은 상속 계층과 계층 중간중간에 함정처럼 숨겨져 있는 메서드 오버라이딩을 만나면 극단적으로 이해하기 어려운 코드가 만들어짐

### 이해할 수 없는 메시지
- 정적 타입 언어인 자바에서 이해할 수 없는 메시지를 전송하면 컴파일 에러를 발생시킴
- 이해할 수 없는 메시지를 처리할 수 있는 동적 타입 언어는 좀 더 순수한 관점에서 객체지향 패러다임을 구현한다고 볼 수 있음
- 동적 타입 언어는 코드를 이해하고 수정하기 어렵게 만들며 디버깅 과정도 복잡함
- 정적 타입 언어는 유연성이 부족하지만 좀 더 안정적임

### self 대 super
- self 참조는 동적임
- super 참조의 정확한 의도는 '지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작하세요'임
- super 전송 = super 참조를 통해 메시지를 전송하는 것

## 12-5 상속 대 위임
- 상속을 바라보는 새로운 시각 = 자식 클래스에서 부모 클래스로 self 참조를 전달하는 메커니즘으로 상속을 바라보는 것

### 위임과 self 참조
- 위임(delegation) = 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것
- 자신이 정의하지 않거나 처리할 수 없는 속성 또는 메서드는 탐색 과정을 다른 객체로 이동시키기 위해 사용
- 위임은 항상 현재의 실행 문맥을 가리키는 self 참조를 인자로 전달함
- self 참조를 전달하지 않는 포워딩과 위임의 차이
- 위임은 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것

### 프로토타입 기반의 객체지향 언어
- 자바스크립트에는 클래스가 존재하지 않기 때문에 오직 객체들 사이의 메시지 위임만을 이용해 다형성을 구현하며 이는 객체지향 패러다임에서 클래스가 필수 요소가 아니라는 점을 잘 보여줌
- 또한 상속 이외의 방법으로도 다형성을 구현할 수 있음

# 읽고 느낀 점
- 지금까지 다형성을 생각하면 상속보다는 인터페이스가 더 먼저 떠올랐는데 이번 챕터에서는 상속의 다형성에 대해 깊게 알 수 있었다
- self 참조같은 부분과 동적 메서드 탐색 과정을 통해 상속 관계에서의 메시지 전송에 대해 깊게 이해할 수 있었다