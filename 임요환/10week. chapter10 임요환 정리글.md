# 간략한 내용 정리

# 10 상속과 코드 재사용
- 객체지향 프로그래밍의 장점 = 코드를 재사용하기 용이함
- 상속 = 클래스를 재사용하기 위해 새로운 클래스를 추가하는 가장 대표적인 기법
- 합성 = 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법

## 10-1 상속과 중복 코드
- 중복 코드는 신뢰를 무너뜨림

### DRY 원칙
- 중복 코드는 변경을 방해함 -> 코드를 수정하는데 필요한 노력을 몇 배로 증가시킴
- 중복 여부 판단 = 요구사항이 변경됐을 때 두 코드를 함께 수정해야 하면 중복임
- DRY(Don't Repeat Youreself, 반복하지 마라) 원칙 = 모든 지식은 시스탬 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 함
- DRY 원칙은 `한 번, 단 한번(Once and Only Once) 원칙` 또는 `단일 지점 제어(Single-Point Control) 원칙`이라고도 부름

### 중복과 변경
- 중복 코드는 새로운 중복 코드를 생성하도록 만듬 -> 코드의 일관성이 무너질 위험이 있음
- 중복 코드가 늘어날수록 애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아짐
- 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제에 시달리게 됨

### 상속을 이용해서 중복 코드 제거하기
- 상속을 이용하면 개발자가 가정을 이해하기 전에는 코드를 이해하기 어려움
    - 만약 전체 통화 시간 중 처음 40초 동안은 10시 이전에, 나머지 50초 동안은 10시 이후에 이뤄졌을 경우 구하는 식
        - 1번 (40초/10초*5원)+(50/10초*2원) = 30원
        - 2번 (40초/10초*5원)+(50초/10초*5원)- (50초/10초*(5원-2원)) = 30원
    - 누구는 1번으로 누구는 2번으로 코드를 작성하게 됨
- 그나마 위의 예제는 쉬운 편이고 상속이 계층의 계층을 거듭할수록 더욱 이해하기 어려운 코드를 마주하게 됨
- 상속은 결합도를 높이며 부모와 자식 사이의 강한 결합이 코드를 수정하기 어렵게 만듬

### 강하게 결합된 Phone과 NightlyDiscountPhone
- 부모와 자식이 강하게 결합되어 있으면 새로운 중복 코드를 만들어야할 가능성이 생김
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합됨 -> super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거해야 함

## 10-2 취약한 기반 클래스 문제
- 취약한 기반 클래스 문제(Fragile Base Class Promblem, Brittle Base Class Problem)
    - 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상
    - 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가르키는 용어
    - 캡슐화를 약화시키고 결합도를 높임
- 상속은 부모클래스를 점진적으로 개선하는게 어려움

### 불필요한 인터페이스 상속 문제
- 대표적인 클래스 예제로 java.util.Properties와 java.util.stack이 있음
```
Stack(String) stack = new Stack(); stack.push("ist");
stack.push("2nd");
stack.push("3rd*);
stack.add(0, "4th");
assertEquals("4th", stack.pop()); / / 에러!

Properties properties = new Properties()); 
properties.setProperty("Bjarne Stroustrup", "C++"); 
properties.setProperty("James Gosling", "Java");
properties.put ("Dennis Ritchie", 67);

assertEquals("C", properties.getProperty("Dennis Ritchie")); // 에러!, properties 객체는 String 값이 아니면 null을 반환함
```
- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있음

### 메서드 오버라이딩의 오작용 문제
- 대표적인 예시로 HashSet의 구현에 감하게 결합된 InstrumentedHashSet 클래스가 있음
```
InstrumentedHashSet<String) languages = new InstrumentedHashSet<>();
languages.addAll(Arrays.asList("Java", "Ruby", "Scala"));

// 위의 예제의 addCount 값은 3이라고 예상되지만 실제 6임, 부모클래스 내부적으로 add 메서드가 한번더 호출되며 3이 한번더 더해짐
```
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있음
- 상속은 코드 재사용을 위해 캡슐화를 희생함

### 부모 클래스와 자식 클래스의 동시 수정 문제
- 상속은 자식 클래스가 부모 클래스의 메서드를 오버라이딩하거나 불필요한 인터페이스를 상속받지 않았음에도 부모 클래스를 수정할 때 자식 클래스를 함께 수정해야 할 수도 있음 -> 자신 클래스가 부모 클래스에 강하게 결합되기 때문임
- 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 지식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없음

## 10-3 Phone 다시 살펴보기
- 추상화를 이용한 위험 완화

### 추상화에 의존하자
- 코드 중복 제거를 위한 상속을 도입할 때의 두 가지 원칙
    - 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라, 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있음
    - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라, 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것 보다 자식 클래스의 추상적인 메서드를 보무 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있음

### 차이를 메서드로 추출하라
- 중복 코드 안에서 차이점을 별도의 메서드로 추출 -> 변하는 것으로부터 변하지 않는 것을 분리하라, 변하는 부분을 찾고 이를 캡슐화하라
- 차이점을 별도로 추출한 후 남은 같은 코드를 부모 클래스로 올리면 됨

### 중복 코드를 부모 클래스로 올려라
- 자식 클래스들의 공통점을 부모 클래스로 옮김으로써 실제 코드를 기반으로 상속 계층을 구성할 수 있음
- 설계가 추상화에 의존하게 됨

### 추상화가 핵심이다
- 공통 코드를 이동시킨 후 각 클래스는 서로 다른 변경의 이유를 가짐 -> 단일 책임 원칙 준수 -> 응집도 높음, 결합도 낮음
- 상속 계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링하라
- 차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라

### 의도를 드러내는 이름 선택하기
- 구현내용을 명식적으로 전달할 수 있는 이름을 선택하라

### 세금 추가하기
- 클래스 사이의 상속은 자식 클래스가 부모 클래스가 구현한 행동뿐만 아니라 인스턴스 변수에 대해서도 결합되게 만듬
- 핵심 로직은 한 곳에 모아 놓고 조심스럽게 캡슐화해야 함
- 공톡적인 핵심 로직은 최대한 추상화해야 함
- 상속으로 인한 클래스 결합을 피할 수 있는 방법은 없음

## 10-4 차이에 의한 프로그래밍
- 차이에 의한 프로그래밍(programming by difference) = 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
- 상속은 코드 중복 제거에 강력한 기능이 있지만 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만듬

# 읽고 느낀 점
- 상속은 자바의 창시자인 제임스 고슬링이 "내가 자바를 만들면서 가장 후회하는 일은 상속을 만든 점이다"라고 말한 것처럼 사용하기 어려운 부분 중 하나라고 생각하고 있었다.
- 이번 챕터를 읽으며 왜 상속이 객체지향 세계에서 좋지 않은지에 대하여 세세하게 알아볼 수 있었다.