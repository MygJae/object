# 다형성
## 00. 개요
- 상속의 목적
	- 코드 재사용이 아닌 타입 계층을 구조화 하기 위함
		- 단순히 코드를 재사용하기 위함인가? 
		- 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위함인가
	- 상속은 다형성을 구현할 수 있는 가장 일반적인 방법
- 다형성 -> 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정에서 구현
	- 탐색경로 -> 클래스 계층의 형태로 구현(상속)
## 01. 다형성
- 다형성 (Polymorphism)
	- 유니버설 다형성 (Universal) 
		- 매개변수 다형성 (Parametric) -> 인스턴스 변수, 매개 변수를 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식
		- 포함 다형성 (Inclusion) -> 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미, 서브타입 다형성, 일반적인 다형성
	- 임시 다형성 (Ad Hoc) 
		- 오버로딩 다형성 (Overloading) -> 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
		- 강제 다형성 (Coercion) -> 자동적인 타입 변환이나 직접 구현한 타입변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식(ex + 연산자)
## 02. 상속의 양면성
* 상속 관점
	* 데이터 관점 ->부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함
	* 행동 관점 -> 데이터뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함 
* 상속 메커니즘
	* 업캐스팅
	* 동적 메서드 탐색
	* 동적 바인딩 
	* self 참조
	* super 참조 -> super가 부모 클래스를 가리키도록 설정된 변수 -> 자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드에 접근하는데 사용
### 상속을 사용한 강의 평가
- 전체 수강생들의 성적 통계를 출력
- GradeLecture에서 Lecture를 상속 받아 원하는 기능을 사용
- 메서드 오버라이딩 -> 부모와 자식에서 evaluate 메서드가 동시에 있을 때 자식 클래스가 실행
	- 자식 클래스 안에서 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것
### 데이터 관점의 상속
- 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것
### 행동 관점의 상속
- 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것
## 03. 업캐스팅과 동적 바인딩
### 같은 메시지, 다른 메서드
- 각 교수별로 강의에 대한 성적 통계를 계산하는 기능 추가
- 업캐스팅과 동적 바인딩 메커니즘
	- 업스캐팅 -> 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능
	- 동적 바인딩 -> 선언된 변수의 타입이 아니라 메시지를 수신하느 ㄴ개체의 타입에 따라 실행되는 메서드가 결정
- 개방-폐쇄 원칙(OCP)과 의존성 역전 원칙(DIP)
- 공통적으로는 코드를 변경하지 않고도 기능을 추가할 수 있게 함 
	- 업스캐팅과 동적 메서드 탐색 -> 목적에 이르는 방법
	- OPC -> 목적이고 추상화가 중심
	- DIP  -> 추상화가 아닌 Lecture에 의존하여 따른다고 보기 어려움
### 업스캐팅
- 업 캐스팅 -> 부모 클래스 타입으로 선언된 파라미터에 자식 클래스의 인스턴스를 전달 가능
- 다운 캐스팅 -> 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요 
### 동적 바인딩
- 함수와 메서드 실행
	- 함수 실행은 함수를 호출
	- 메서드 실행은 메시지를 전송
- 컴파일타임과 런타임
	- 컴파일타임에 호출할 함수를 결정하는 방식 -> 정적 바인딩, 초기 바인딩, 컴파일타임 바인딩
	- 런타임에 실행될 메서드를 결정하는 방식 -> 동적 바인딩, 지연 바인딩
## 04. 동적 메서드 탐색과 다형성
- 메서드 실행
	- 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사
	- 존재하면 메서드를 실행하고 탐색 종료
	- 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속 진행
	- 적합한 메서드를 찾을 때까지 상속 계층을 탐색
	- 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색 중단
- self와 this
	- 정적 타입 언어에 속하는 C++, 자바, C#에서는 self참조를 this라고 함
- 메시지 탐색
	- 메시지 탐색 경로 -> 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정
	- 자동적 메시지 위임 -> 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄지며 메서드 탐색이 종료되면 self 참조는 자동으로 소멸
	- 동적인 문맥 -> class 포인터, parent 포인터, self참조를 조합해 메서드 탐색
### 자동적인 메시지 위임
- 메서드 오버로딩 -> 부모 클래스에서 메서드가 존재하여 실행
- 메서드 오버라이딩 -> 자식 클래스가 부모 클래스에 존재하는 메서드와 동일한 시그니처를 가진 메서드를 재정의해서 부모 클래스의 메서드를 감추는 현상
### 동적인 문맥
- 메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀌는데, 이 동적인 문맥을 결정하는 것이 self 참조
- self 전송 -> 자신에게 다시 메시지를 전송하는 것
### 이해할 수 없는 메시지
- 이해할 수 없는 메시지와 도메인-특화 언어
	- 동적 리셉션- > 동적 타입 언어의 특징을 이용해 도메인-특화 언어를 개발하는 방식
- 동적 메서드 탐색을 혼합해서 동일한 코드를 이용해 서로 다른 메서드를 실행 가능
- 동일한 코드를 이용하여 서로 다른 메서드를 실행하는 것이 가능
### self 대 super
- 자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드를 접근하기 위해 사용할 수 있는 super 참조를 내부 변수를 제공
- super 참조
	- 부모 클래스에서부터 메서드 탐색
	- 그 클래스의 조상 어디인가에 그 메서드가 정의돼 있기만 하면 실행 가능
- self전송은 메시지 탐색을 시작하는 클래스는 미정
- super전송은 항상 해당 클래스의 부모 클래스에서부터 시작
## 05. 상속 대 위임
- 다형성은 self 참조가 가리키는 현재 객체에게 메시지를 전달하는 특성을 기반으로 동일한 타입의 객체 참조에게 동일한 메시지를 전송하더라도 self 참조가 가리키는 객체의 클래스가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 달라짐
- 상속은 자식 클래스에서 부모 클래스로 self 참조를 전달하는 메커니즘
### 위임과 self 참조
- 위임 -> 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것
	- 자신이 정의하지 않거나 처리할 수 없는 속성 또는 메서드의 탐색 과정을 다른 객체로 이동시키기 위해 사용
	- 항상 현재의 실행 문맥을 가리키는 self 참조를 인자로 전달
- 포워딩과 위임
	- 포워딩 -> self참조를 전달하지 않는 경우
	- 위임 -> 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현
### 프로토타입 기반의 객체지향 언어
- 객체 사이의 자동적인 메시지 위임을 통해 상속을 구현
- 클래스 기반의 상속과 객체 기반의 위임 사이에 기본 개념과 메커니즘을 공유한다는 점
## 읽고 느낀점
- 상속은 코드 재사용이 아닌 계층을 구조화 하기 위한다는 것
- 메서드가 어떻게 실행하고 어떤 순서로하고 이것이 다형성과 연결되는 것 그리고 그 방법으로는 상속이 사용 됨


