# 서브클래싱과 서브타이핑
## 00. 개요
- 상속을 사용하는 용도
	- 타입 계층
		- 부모 클래스는 자식 클래스의 일반화
		- 자식 클래스는 부모 클래스의 특수화
	- 코드 재사용
		- 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드가 됨
- 다형성
	- 동일한 메시지에 대한 서로 다르게 행동할 수 있는 다형적 객체
		- 객체의 행동을 기반으로 타입 계층을 구성해야 함
- 객체기반 프로그래밍
	- 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식
- 객체지향 프로그래밍
	- 상속과 다형성을 지원
## 01. 타입
### 개념 관점의 타입
- 우리가 인지하는 세상의 사물의 종류를 의미
	- 타입 -> 사물을 분류하기 위한 틀
- 타입의 심볼 -> 프로그래밍 언어
- 타입의 인스턴스(객체) -> 자바, 루비
- 내연 -> 객체들이 가지는 공통적인 속성이나 행동의 집합
- 외연 -> 객체들의 집합
### 프로그램이 언어 관점의 타입
- 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 실수방지에 사용
- 목적
	- 타입에 수행 될 수 잇는 유효한 오퍼레이션의 집합
	- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공
### 객체지향 패러다임 관점의 타입
- 오퍼레이션 -> 객체가 수신할 수 있는 메시지
- 객체의 타입 -> 객체가 수신할 수 있는 메시지의 종류
- 퍼블릭 인터페이스 -> 객체가 수신할 수 있는 메시지 집합
- 객체의 퍼블릭 인터페이스가 객체의 타입을 결정
	- 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면 이들은 서로 다른 타입으로 분류
	- 객체의 타입을 결정은 내부속성이 아니라 외부에 제공하는 행동이 결정
## 02. 타입 계층
### 타입 사이의 포함관계
- 타입 계층의 표현
	- 일반적인 타입은 위쪽, 더 특수한 타입은 아래에 배치
- 슈퍼타입
	- 집합이 다른 집합의 모든 맴버를 포함
	- 두 타입 간의 관계에서 더 일반적인 타입
- 서브타입
	- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함
	- 타입 정의가 다른 타입보다 구체적
	- 더 특수한 타입
- 내연관점(객체의 정의)
	- 일반화 -> 어떤 타입의 정의를 좀 더 보편적으로 추상적으로 만드는 과정
	- 특수화 -> 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정
	- 특수한 타입 -> 일반적인 타입의 정의를 좀 더 구체화한 것
- 외연관점(집합을 의미)
	- 일반적인 타입의 인스턴스 집합 -> 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋
	- 특수한 타입의 인스턴스 집합 -> 일반적인 타입의 인스턴스 집합에 포함된 서브셋 
	- 특수한 타입에 속한 인스턴스는 동시에 더 일반적인 타입의 인스턴스
### 객체지향 프로그램이과 타입 계층
- 슈퍼타입
	- 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의
- 서브타입
	- 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의
## 03. 서브클래싱과 서브타이핑
- 상속을 이용해 타입 계층을 구현
	- 부모 클래스가 슈퍼타입의 역할
	- 자식 클래스가 서브타입의 역할
### 언제 상속을 사용해야 하는가?
- 타입 계층을 구현할때 상속 사용
	- 상속 관계가 is-a관계를 모델링하는가
	- 클라이언트 입장에서 부모 클래스 타입으로 자식 클래스를 사용해도 무방한가
		- 행동 호환성 -> 상속 계층을 사용하는 클라이언트 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 함
### is-a 관계
- 두 클래스가 어휘적으로 is-a관계를 모델링할 경우에만 상속을 사용해야 함
	- 어떤 타입 S가 다른 타입 T의 일종이라면 타입S는 타입 T다(S is-a T)
- 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 함
	- 펭귄은 새지만 만약 새의 정의에 날 수 있다는 행동이 포함된다면 펭귄은 새의 서브타입이 될 수 없다
### 행동 호환성
- 타입이 행동과 관련
	- 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a관계를 사용하면 안됨
	- 두 타입 사이에 행동이 호환될 경웨만 타입 계층으로 묶어야 함
	- 클라이언트 관점에서 생각해야 함
### 클라이언트의 기대에 따라 계층 분리하기
- 인터페이스 분리 원칙(ISP)
	- 날 수 있는 새와 날 수 없는 새로 분리
- 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중해야 함
	- 두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니기 때문에 상속을 사용해서는 안됨
### 서브클래싱과 서브타이핑
- 서브클래싱
	- 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
	- 구현상속, 클래스상속
- 서브타이핑
	- 타입 계층을 구성하기 위해 상속을 사용하는 경우
	- 인터페이스 상속
## 04. 리스코프 치환 원칙
- 상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키는 조건
	- 서브타입은 그것의 기반 타입에 대해 대체 가능해야 함
	- 클라이언트가 차이점을 인식 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용 해야 함
### 클라이언트와 대체 가능성
- 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것은 불가능
- 대체 가능성을 결정하는것은 클라이언트임
### is-a 관계 다시 살펴보기
- 상속이 서브타이핑을 위해 사용될 경우에만 is-a관계
- 서브클래싱을 구현하기 위해 상속을 사용했다면 is-a관계라고 할 수 없음
### 리스코프 치환 원칙은 유연한 설계의 기반이다
- 의존성 역전 원칙
- 리스코프 치환 원칙
- 개방-폐쇄 원칙
### 타입 계층과 리스코프 치환 원칙
- 클래스의 상속은 타입 계층을 구현할 수 있는 방법 중 하나임
- 구현 방법과 무관하게 클라이언트 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용 되야 함
## 05. 계약에 의한 설계와 서브타이핑
- 계약에 의한 설계
	- 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현
- 요소
	- 사전조건 -> 계약에 의한 설계는 클라이언트가 정상적으로 메서드를 실행하기 위함
	- 사후조건 -> 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 함
	- 클래스 불변식 -> 메서드 실행 전과 실행 후에 인스턴스를 만족해야 함
### 서브타입과 계약
- 계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있음
- 서브타입 조건
	- 더 강력한 사전조건을 정의할 수 없음
	- 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 없음
	- 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 없음
	- 더 약한 사후조건을 정의할 수 없음
## 읽고 느낀점
- 상속의 목적은 코드 재사용이 아닌 타입 계층 분리에 있었고, 코드 재사용으로 사용하면 변경이 어렵게 된다


