# 계약에 의한 설계
## 00. 개요
- 계약에 의한 설계 -> 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화 할 수 있음
## 01. 협력과 계약
### 부수효과를 명시적으로
- 메시지의 이름과 파라미터 목록
	- 시그니처를 통해 전달
- 협력을 위해 필요한 약속과 제약
	- 인터페이스를 통해 전달 X, 암시적인 상태로 남음
- 명령-쿼리 분리 원칙
	- Event 클래스의 클라이언트는 먼저 IsSatisfied 메서드 호출해서 RecurringSchedule의 조건을 만족키시는지 여부를 확인 후 Reschedule 메서드를 호출
	- Code Contracts를 사용하여 메서드의 반환값이 true일 경우를 표현
### 계약
- 일반적인 각 계약 당사자 특징
	- 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행
	- 이익과 의무는 계약서에 문서화
	-  -> 한쪽의 의무가 반대쪽의 권리가 됨
- 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어
## 02. 계약에 의한 설계
### 사전조건
- 협력에 참여하는 두 객체 사이의 의무와 이익을 문서화
	- 이익을 기대하고 이익을 얻기 위해 의무를 이행
	- 이익과 의무는 객체의 인터페이스 상에 문서화
- 계약에 의한 설계를 구성하는 세가지 요소
	- 사전조건
		- 메서드가 호출되기 위해 만족돼야 하는 조건
		- 메서드의 요구사항을 명시
		- 사전조건이 만족되지 않을 경우 메서드가 실행되서는 안됨
		- 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무
	- 사후조건
		- 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건
		- 클라이언트가 사전조건을 만족시켰다면 명시된 조건을 만족시켜야 함
		- 클라이언트가 사전조건을 만족시켰는데도 사후조건을 만족시키지 못한 경우 클라이언트에게 예외처리
		- 사후조건을 만족시키는것은 서버의 의무
	- 불변식
		- 항상 참이라고 보장되는 서버의 조건
		- 메서드가 실행되는 도중에는 불변식을 만족시키지 못할 수도 있음
		- 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참
- 일반적으로 사전조건은 메서드에 전달된 인자의 정합성을 체크하기 위해 사용
### 사후조건
- 일반적으로 세가지 용도로 사용
	- 인스턴스 변수의 상태가 올바른지를 서술하기 위해
	- 메서드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해
	- 반환값이 올바른지를 서술하기 위해
- 사전조건보다 사후조건을 정의하는것이 어려운 이유
	- 한 메서드안에서 return 문이 여러번 나올 경우
	- 실행 전과 실행 후의 값을 비교해야 하는 경우
### 불변식
- 특성
	- 클래스의 모든 인스턴스가 생성된 후에 만족돼야 함
	- 클래스에 정의된 모든 생성자는 불변식을 준수해야 함
	- 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수돼야 함
	- 메서드가 실행되는 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요는 없지만 메서드 실행 전과 메서드 종료 후에는 항상 불변식을 만족하는 상태가 유지돼야 함
## 03. 계약에 의한 설계와 서브타이핑
- 리스코프 치환 원칙 
	- 협력에 참여하는 객체에 대한 기대를 표현하는 계약 규칙
	- 교체 가능한 타입과 관련된 가변성 규칙
- 계약 규칙
	- 서브타입에 더 강력한 사전조건을 정의할 수 없음
	- 서브타임에 더 완화된 사후존건을 정의할 수 없음
	- 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 함
- 가변성 규칙
	- 서브타임의 메서드 파라미터는 반공변성을 가져야 함
	- 서브타임의 리턴 타입은 공변성을 가져야 함
	- 서브타임은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안됨
- 공변성과 반공변성이 중요해지는 곳은 상속이 제네릭 프로그래밍과 만나는 지점
### 계약 규칙
- RatePolicy 기본 정책과 부가 정책을 구현하는 모든 객체들이 실체화해야 하는 인터페이스
- RatePolicy의 calculateFee의 사후조건 정의
- calculateFee의 사전조건 정의
- BasicRatePolicy에 사전조건과 사후조건 추가
- AdditionalRatePolicy에 사전조건과 사후조건 추가
### 가변성 규칙
- RatePolicy의 calculateFee 오퍼레이션이 인자로 빈 리스트를 전달받았을 때 EmptyCallException 예외를 던지도록 계약 수정
- EmptyCallException
- NoneElementException
- S가 T의 서브타입 두 타입 사이의 치환 가능성
	- 공변성 -> S와 T 사이의 서브타입 관계가 그대로 유지, 서브타입S가 슈퍼타입 T 대신 사용 가능리스코프 치환 원칙
	- 반공변성 -> S와 T 사이의 서브타입 관계가 역전, 슈퍼타입인 T가 서브타입인 S대신 사용 가능
	- 무공변성 -> S와 T 사이에는 아무런 관계가 존재하지 않음, 대신 사용 못함
### 함수 타입과 서브타이핑
- 객체지향 언어들은 이름 없는 메서드를 정의할 수 있게 허용
- 익명 함수, 함수 리터럴, 람다 표현식
## 읽고 느낀점
- 사전조건, 사후조건, 불변식 개념을 알 수 있었다.
- 이해는 가지만 용어가 생소함
