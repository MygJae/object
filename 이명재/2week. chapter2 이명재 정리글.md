# 객체지향 프로그래밍

## 01. 영화 예매 시스템
### 영화와 상영 둘로 나누기
- 영화는 영화에 대한 기본정보 -> 제목, 상영시간, 가격 정보 등
- 상영은 실제 관객들이 영화를 관람하는 사건 -> 상영 일자, 시간, 순번 등
  - 영화는 하루 중 다양한 시간대에 걸쳐 한 번 이상 상영
- 특정 조건에 따른 요금 할인 -> 할인 조건, 할인 정책
  - 할인 조건 -> 순서 조건과 기간 조건
    - 순서 조건 -> 상영 순번을 이용해 할인 여부를 결정
    - 기간 조건 -> 상영 시작 시간을 이용해 할인 여부 결정
  - 할인 정책 -> 금액 할인 정책, 비율 할인 정책
    - 금액 할인 정책 -> 예매 요금에서 일정 금액을 할인
    - 비율 할인 정책 -> 정가에서 일정 비율의 요금을 할인
## 02. 객체지향 프로그래밍을 향해
### 객체의 초점으로 프로그래밍
- 어떤클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민
- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원
### 도메인의 구조
- 사용자가 프로그램을 사용하는 분야 -> 도메인
- 도메인의 개념과 관계를 반영하도록 프로그램을 구조화해야 하기 때문에 클래스의 구조도 도메인의 구조와 유사한 형태가 됨
### 도메인 개념의 구조를 따르는 클래스 구조
- 클래스 영화 Movie
- 클래스 상영 Screening
- 클래스 할인 조건 DiscountCondition
- 클래스 순번 조건 SequenceCondition
- 클래스 기간 조건 periodCondition
- 클래스 할인 정책 DiscountPolicy
- 클래스 금액 할인 정책 AmountDiscountPolicy
- 클래스 비율 할인 정책 PercentDiscountPolicy
- 클래스 예매 Reservation
### 클래스 구현하기
#### 상영 Screening
- 인스턴스 영화 movie, 순번 sequence, 상영 시작 시간 whenScreened
- 메서드 상영 시작 시간을 반환 getStartTime, 순번의 일치 여부 isSequence, 기본 요금을 반환 getMovieFee
- 인스턴스 변수의 가시성 private, 메서드의 가시성 public
  - 객체의 상태는 숨기고 행동만 외부에 공개
    - 객체의 자율성을 보장
      - **접근 제어** -> 외부에서의 접근을 통제
      - **캡슐화** -> 데이터와 기능을 객체 내부로 함께 묶는 것
    - 외부 접근 불가능하고 내무에서만 접근 가능한 부분을 구현(impl)이라고 함
    - 정보 은닉
- 메서드 reserve
  - calculateFee 메서드로 요금 계산하고 그 결과를 Reservation의 생성자에 전달
  - calculateFee 메서드는 요금 계산을 위해 Movie의 calculateMovieFee 메서드에서 1인당 예매 요금 호출
  - calculateMovieFee 메서드 값과 인원수 audienceCount 곱하여 전체 요금 구하기
#### 금액 Money
- 계산 구현
#### 예매 Reservation
- 인스턴스 고객 customer, 상영 정보 screnning, 요금 fee, 인원수 audienceCount
### 정리
#### 상영, 영화, 예매의 협력
- 협력의 관점에서 어떤 객체가 필요한지 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성
#### 메시지와 메서드
- 메서드 호출은 메시지 전송이라고 함
- 메서드는 수신된 메시지를 처리하기 위한 것
- Screening은 Movie의 calculateMovieFee 메서드가 존재하고 있는지 모르고, 단지 Movie가 calculateMovieFee 메시지에 응답 할 수 있다고 믿고 메시지를 전송하는 것. 메시지를 수신한 Movie는 스스로 적절한 메서드를 선택한 것
## 03. 할인 요금 구하기
### 클래스 구현하기
#### 영화 Movie
- 제목 title, 상영시간 renningTime, 기본요금 fee, 할인 정책 discountPolicy 
- 할인 정책 코드가 없고 단지 discountPolicy에 메시지를 전송 함
- **상속**, **다형성**이 적용 됨
  - **추상화**라는 기반
#### 할인 정책 DiscountPolicy
- 부모 클래스
- 추상 클래스
  - 인스턴스를 생성할 필요 없기 때문에 구현
- DiscountCondition의 리스트 conditions를 인스턴스 변수 -> 하나의 할인 정책은 여러 개의 할인 조건을 포함
- 메서드 calculateDiscountAmount는 전체 할인 조건에 대하여 차례대로 DiscountCondition의 메서드 isSatisfiedBy를 호출 -> screening의 전달받은 할인 조건이 만족 여부 -> true,false
- true -> 메서드 getDiscountAmount에서 할인 요금 계산
- DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메서드가 실행
- **TEMPLATE METHOD 패턴** -> 부모 클래스에 기본적인 알고리즘 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴
#### 할인 조건 DiscountCondition
- 인터페이스 선언
#### 순번 조건 SequenceCondition impl DiscountCondition
- 인스턴스 sequence
- 메서드 isSatisfiedBy의 상영 순번과 일치할 경우 할인 가능한 것으로 판단
#### 기간 조건 periodCondition impl DiscountCondition
- 인스턴스 요일 dayOfWeek, 시작 시간 startTime, 종료 시간 endTime 
#### 금액 할인 정책 AmountDiscountPolicy extends DiscountPolicy
- 자식 클래스
- 메서드 getDiscountAmount 오더라이딩
- 인스턴스 discountAmount 할인 요금 저장
#### 비율 할인 정책 PercentDiscountPolicy extends DiscountPolicy
- 자식 클래스
- 메서드 getDiscountAmount 오더라이딩
- 인스턴스 percent 할인 비율 저장
### 할인 정책 구성
- 할인 정책으로 금액 할인 정책이 적용, 두 개의 순서 조건과 기간 조건을 이용해 할인 여부 판단
### 오버라이딩,오버로딩
- 오버라이딩 -> 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의
  - 오버라이딩은 다형성의 한 형태로, 메서드 호출 시 메서드를 찾는 순서는 메서드를 호출하는 객체의 타입에 따라 결정. 부모 클래스에 있는 메서드를 그대로 사용하기보다는 자식 클래스의 특정 동작이 필요한 경우에 오버라이딩을 사용
- 오버로딩 -> 같은 이름의 메서드를 다른 매개변수로 여러 개 선언
  - 호출 시 전달되는 매개변수에 따라 적절한 메서드가 선택되어 실행. 오버로딩은 다형성을 향상시키고 코드의 가독성을 높이기 위해 사용.
## 04. 상속과 다형성
- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려움. 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아짐
  - 유연성과 가독성 사이 고민 필요
### 상속
- 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법 -> 차이에 의한 프로그래밍
- 업스캐팅 -> 자식 클래스가 부모 클래스를 대신하는 것
- 일반적인 생각 상속의 목전이 메서드나 인스턴스 변수를 재사용 하는 것
  - 메시지를 수신할 수 있다는 사실이 중요
### 다형성
- 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 것
  - 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해 할 수 있어야 함
    - 인터페이스가 동일해야 함
### 구현상속(서브클래싱), 인터페이스 상속(서브타이핑)
- 구현상속 -> 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것
- 인터페이스 상속 -> 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속
  - 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 함
  - 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드가 발생 됨
## 05. 추상화와 유연성
### 추상화
- 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 의미
- 재사용 가능한 설계의 기본을 이루는 디자인패턴이나 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 메커니즘을 활용
### 유연한 설계
- 클래스 NoneDiscountPolicy을 추가 하므로 기존 클래스를 수정하지 않고 애플리케이션기능을 확장 가능
  - 유연성이 필요한 곳에 추상화를 사용할 수 있도록 함
### 합성
- 상속 보다는 합성이 좋은 방법
  - 합성 -> 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법
### 상속 
- 상속은 캡슐화 위반, 설계를 유연하지 못하게 함
### 정리
- 대부분의 설계에서는 상속과 합성을 함께 사용하고 재사용하는 경우에는 상속보다 합성을 선호하는 것이 옳지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용 할 수 밖에 없음

