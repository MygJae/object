# 책임 할당하기
## 00. 코드 설계
- 데이터 중심 설계는 책임에 초첨이 안되서 문제
- 책임 중심 설계는 어떤 객체에게 책임을 할당할지 결정하기가 쉽지 않음 
	-  GRASP 패턴으로 해결하기
## 01. 책임 주도 설계를 향해
- 책임 중심의 설계 두가지 원칙
	- 데이터보다 행동을 먼저 결정
	- 협력이라는 문맥 안에서 책임을 결정
### 데이터보다 행동을 먼저 결정
- 객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 **행동**
- 객체는 협력에 참여하기 위해 존재하며 협력 안에서 수행하는 책임이 객체의 존재가치를 증명
- 데이터는 객체가 책임을 수행하는데 필요한 재료를 제공만 할 뿐
- 객체의 책임(행동))을 결정 후에 객체의 상태를 결정
### 협력이라는 문맥 안에서 책임을 결정
- 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 함
- 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당
- 메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요하다고 생각해야 함
	- 객체를 만들고 메시지를 처리하는게 아니라 메시지를 먼저 생각하고 그에 필요한 객체를 생성
### 책임 주도 설계
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악 -> 메시지가 무엇인지?
- 시스템 책임을 더 작은 책임으로 분할
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾음
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력
##### 협력 메시지 행동 책임 상태 데이터 역할 객체
## 02. 책임 할당을 위한 GRASP 패턴
- General Responsibility Assignment Software Pattern - 일반적인 책임 할당을 위한 소프트웨어 패턴
### 도메인 개념에서 출발
- 설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 보는 것이 유용
- 시작 단계에서 개념들의 의미와 관계가 완벽할 필요는 없고 책임을 할당 받을 객체의 종류와 관계 정보면 충분
- 도메인 개념을 정리하는데 너무 많은 시간을 할당하기 보다는 설계와 구현에 집중
- 올바른 도메인 모델이란 존재하지 않음
	- 도메인 모델은 도메인을 개념적으로 표현한 것이지만 그 안에 포함된 개념과 관계는 구현의 기반이 돼야 함
	- 유연성이나 재사용성 등과 같이 실제 코드를 구현하면서 얻게 되는 통찰이 역으로 도메인에 대한 개념을 바꾸기 때문에 실용적이면서 유용한 모델이 되어야 함
### 정보 전문가에게 책임을 할당
- 영화를 예매하라
	- 메시지를 전송할 객체는 무엇을 원하는가?
		- 메시지의 이름은 예매하라
	- 메시지를 수신할 적합한 객체는 누구인가?
		- GRASP -> Information Expert(정보 전문가) 패턴
			- 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당
	- Screening 상영 
		- 외부
			- 예매하는데 필요한 정보를 가장 많이 알고 있는 객체
			- 영화를 예매하라의 메시지를 책임 할 정보 전문가
		- 내부
			- 예매하라를 수행 -> 가격 계산이 필요
			- 가격 계산이 필요를 위해 외부 요청 -> Moive 영화
			- Movie 영화에서 할인 여부를 판단을 위해 외부 요청 -> DiscountCondition 할인 여부
			- 예매 완료
### 높은 응집도와 낮은 결합도
- 설계는 트레이드오프 활동
- GRASP -> LOW COUPLING(낮은 결합도) 패턴
	- 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당
	- Screening에서 바로 DiscountCondition와 협력할 경우 새로운 결합도가 추가 되므로 Moive와 협력하는게 더 나은 설계
- GRASP -> HIGHT COHESION(높은 응집도) 패턴
	- 설계 결정에서 높은 응집도를 유지할 수 있게 책임을 할당
	- Screening에서 바로 DiscountCondition와 협력할 경우 예매 요금 방식이 변경 될 경우 Screening도 같이 변경 되므로 응집도가 낮게 됨
### 창조자에게 객체 생성 책임을 할당
- GRASP -> CREATOR(창조자) 패턴
	- 사용할 수 있는 책임 할당 패턴으로서 객체를 생성할 책임을 어떤 객체에게 할당할지에 대해 지침을 제공
	- 객체 A를 생성할 때 B에게 객채 생성 책임을 할당
		- B가 A 객체를 포함하거나 참조
		- B가 A 객체를 기록
		- B가 A 객체를 긴밀하게 사용
		- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있음(B는 A에 정보 전문가)
- Reservation 예약
	- Screening 상영은 예매 정보를 생성하는데 정보 전문가
		- 영화, 상영 시간, 상영 순번 등
		- 예매 요금 계산하는 Movie도 알고 있음
	- Reservation 예약의 CREATOR로 Screening 상영을 선택하는 것이 적절함
## 03. 구현을 통한 검증
- Screening 상영 구현
	- 예매하라 메시지를 처리할 수 있는 메서드
	- 상영시간, 상영순번, 영화 
	- Reservation 예약을 생성해 반환
	- movie.calculateMovieFee -> Screening이 Movie의 내부 구현에 대한 어떤한 지식도 없이 전송할 메시지를 결정 -> Movie의 내부 구현을 캡슐화
- Movie 영화 구현
	- 기본 금액, 할인 조건, 할인 정책
	- Movie 할인 금액, 할인 비율
	- 할인 요금 계산 calculateDiscountAmount 메서드 호출
- DiscountCondition 할인 여부 구현
	- 요일, 시작 시간, 종료 시간, 상영 순번
### DiscountCondition 개선
- 변경에 취약한 클래스 포함 -> 수정해야 하는 이유를 하나 이상 가지는 클래스
	- 새로운 할인 조건 추가
	- 순번 조건을 판단하는 로직 변경
	- 기간 조건을 판단하는 로직이 변경되는 경우
- 코드를 통해 변경 이유
	- 하나 이상의 변경 이유를 가지기 떄문에 응집도가 낮음
		- 변경의 이유에 따라 클래스를 분리 해야 해결 됨
	- 인스턴스 변수가 초기화되는 시점
		- 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화
		- 함께 초기화되는 속성을 기준으로 코드를 분리
	- 메서드들이 인스턴스 변수를 사용하는 방식
		- 모든 메서드가 객체의 모든 속성을 사용하면 클래스의 응집도가 높다
		- 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리
### 타입 분리
- DiscountCondition의 문제는 순번 조건과 기간 조건의 독립적인 타입이 하나의 클래스에 공존한다는 점
- PeriodCondition 클래스
	- dayOfWeek, startTime, endTime
- SequenceCondition 클래스
	- sequence
- Movie 클래스
	- 문제점 발생
		- PeriodCondition, SequenceCondition 양쪽 모두 결합
		- 새로운 할인 조건을 추가하기 어려워 짐
	- 응집도는 옾아 졌지만, 변경과 캡슐화라는 관점에서 나빠짐
### 다형성을 통해 분리
- 역할
	- Movie에서 동일한 책임을 수행한다는 것은 동일한 역할을 수행한다는 것을 의미
	- 인터페이스와 추상클래스 이용
		- 추상 클래스 -> 역할을 대체할 클래스들 사이에서 구현을 공유해야 할 필요
		- 인터페이스 -> 수현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만을 정의
	- DiscountCondition의 인터페이스를 이용
- GRASP -> POLYMORPHISM(다형성) 패턴
	- 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당
### 변경으로부터 보호
- GRASP -> PROTECTED VARIATIONS(변경 보호) 패턴
	- 변경을 캡슐화하도록 책임을 할당
- POLYMORPHISM 패턴과 PROTECTED VARIATIONS 패턴을 이용하여 변경과 확장 대처
	- POLYMORPHISM 패턴 ->하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 책임을 분산 시킴
	- PROTECTED VARIATIONS 패턴 -> 예측 가능한 변경으로 인해 여러 클래스들이 불안정해지면 안정적인 인터페이스 뒤로 변경을 캡슐화 함
### Movie 클래스 개선
- AmountDiscountMovie 클래스
	- 금액 할인 정책과 관련된 인스턴스 변수와 메서드를 옮김
- PercentDiscountMovie 클래스
	- 비율 할인 정책과 관련된 인스턴스 변수와 메서드를 옮김
- NoneDiscountMovie 클래스
	- 할인 정책을 적용하지 않는 경우
- 모든 클래스의 내부 구현은 캡슐화돼 있고 모든 클래스는 변경의 이유를 오직 하나씩만 가짐
### 도메인의 구조가 코드의 구조를 이끈다
- 도메인 모델에는 도메인 안에서 변하는 개념과 이들 사이의 관계가 투영돼 있어야 함
- 객체지향은 도메인의 개념과 구조를 반영한 코드를 가능하게 만들기 때문에 도메인의 구조가 코드의 구조를 이끌어 내는 것은 자연스러울뿐만 아니라 바람직 하다.
### 변경과 유연성
- 변경에 대비 방법
	- 기본적으로 하나의 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계
	- 만약 유사한 변경이 반복적으로 발생하면 코드를 수정하지 않고도 변경을 수요할 수 있도록 코드를 더 유연하게 만드는 것
- 상속 대신 합성
	- 새로운 할인 정책이 추가될 때마다 인스턴스를 생성하고, 상태를 복사하고, 식별자를 관리하는 코드를 추가하는 일은 오류를 야기함
	- 코드의 복잡성이 높아지더라도 할인 정책의 변경을 쉽게 수요할 수 있게 코드를 유연하게 만드는 것이 좋은 방법
## 04. 책임 주도 설계의 대안
- 절차형 코드로 실행되는 프로그램을 구현 후 객체지향적으로 코드로 리팩터링 하기
### 메서드 응집도
- 영화 예매를 처리하는 모든 절차는 ReservationAgency에 있고, 이 안에 있는 로직을 객체의 책임으로 분배하면 책임 주도 설계와 유사한 결과를 얻을 수 있음
- Monster Method 몬스터 메서드
	- 긴 메서드는 응집도가 낮기 때문에 이해하기 어렵고 재사용하기도 어려우며 변경하기도 어려움
- 이해하기 쉬운 이름으로 된 메서드
	- 메서드가 잘게 나눠져 있을 때 다른 메서드에서 사용될 확률이 높고 오버라이딩 하는것도 쉬움
	- 고수준의 메서드를 볼 때 일련의 주석을 읽는 것 같은 느낌이 들게 함
### 객체를 자율적으로 만들기
- 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체
- 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동
- 캡슐화, 결합도, 응집도를 이해하고 객체지향 원칙을 적용하는게 중요
## 읽고 느낀점
- 대략적인 느낌은 알겠지만, 객체지향적으로 구현을 한다는것, 책임을 부여하는 것이 쉽지 않다라는게 느껴진다.
- 처음부터 책임 주도 설계를 하기 힘들어 보여, 데이터 중심으로 설계를 한 후에 리팩토링하는 방식으로 연습하면 좋겠다.

