# 일관성 있는 협력
## 00. 개요
- 객체지향 설계
	- 바탕
		- 객체는 협력을 위해 존재
		- 협력은 객체가 존재하는 이유와 문맥을 제공
	- 장점
		- 애플리케이션이 이해하기 쉬움
		- 수정이 용이
		- 재사용 가능한 협력의 모임
	- 목표
		- 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것
	- 재사용 방법
		- 객체들의 협력 방식을 일관성 있게 만들어야 함
		- 협력 패턴을 사용 해야 함
## 01. 핸드폰 과금 시스템 변경하기
### 기본 정책 확장
- 요금 정책 수정으로 4가지 방식으로 확장
	- 고정요금 방식
		- 일정 시간 단위로 동일한 요금을 부과하는 방식
	- 시간대별 방식
		- 하루 24시간을 특정한 시간 구간으로 나눈 후 구간별로 서로 다른 요금을 부과하는 방식
	- 요일별 방식
		- 요일별로 요금을 차등 부과하는 방식
	- 구간별 방식
		- 전체 통화 시간을 일정한 통화 시간에 따라 나누고 각 구간별로 요금을 차등 부과하는 방식
### 고정요금 방식 구현하기
- 기존의 일반요금제와 동일
- RegularPolicy -> FixedFeePolicy 변경
### 시간대별 방식 구현하기
- 통화 기간을 정해진 시간대별로 나누 후 각 시대별로 서로 다른 계산 규칙 적용
- DateTimeInterval 추가
- 통화시간을 일자와 시간 기준으로 분할
	- 통화 기간을 일자로 분리
	- 일자별로 분리된 기간을 다시 시간대별 규칙에 따라 분리한 후 각 기간에 대해 요금 계산
- TimeOfDatDiscountPolicy 구현
	- 시간에 따라 서로 다른 요금 규칙을 정의
### 요일별 방식 구현하기
- 요일별로 요금 규칙을 다르게 설정
	- 요일의 목록, 단위 시간, 단위 요금
### 구간별 방식 구현하기
- 코드재사용하기 위해 FixedFeePolicy 클래스를 상속
- DurationDiscountRate 클래스의 calculate 메서드 안에서 부모 클래스의 calculateFee 메서드를 호출
	- 기본 정책을 구현하는 기존 클래스들과 일관성이 없음
	- 코드 재상용을 위한 상속은 해로움
## 02. 설계에 일관성 부여하기
* 일관성있는 설계를 만드는데는 다양한 설계 경험이 중요
	* 디자인 패턴을 학습
* 협력을 일관성 있게 만들기
	* 변하는 개념을 변하지 않는 개념으로부터 분리
	* 변하는 개념을 캡슐화
### 조건 로직 대 객체 탐색
- ReservationAgency 기본 로직 정리
- 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 커다란 클래스를 더 작은 클래스로 분리
	- 변경의 이유와 주기 기준 잡기
	- 단일 책임 원칙을 따르도록 클래스를 분리
- 일관성 있는 협력을 위한 지침
	- 변하는 개념을 변하지 않는 개념으로부터 분리
	- 변하는 개념을 캡슐화
- 변경에 초첨을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴을 얻음
### 캡슐화 다시 살펴보기
- 데이터를 단순히 은닉이라기 보다는 소프트웨어 안에서 변할 수 있는 모든 개념을 감추는 것
	- 데이터 캡슐화 -> 클래스는 내부에 관리하는 데이터를 캡슐화
	- 메서드 캡슐화 -> 클래스의 내부 행동을 캡슐화
	- 객체 캡슐화 -> 객체와 객체 사이의 관계를 캡슐화
	- 서브타입 캡슐화 -> 다형성 기반
- 코드 수정으로 인해 파급효과를 제어
	- 일반적으로 서브타입 캡슐화는 인터페이스 상속, 객체 캡슐화는 합성 사용
		- 변하는 부분을 분리해서 타입 계층 만듬
		- 변하지 않는 부분의 일부로 타입 계층을 합성
## 03. 일관성 있는 기본 정책 구현하기
### 변경 분리하기
- 변하는 개념과 변하지 않는 개념을 분리
	- 기본 정책은 한 개 이상의 규칙으로 구성
	- 하나의 규칙은 적용조건과 단위요금을 조합
- 단위요금
	- 단위시간당 요금 정보를 의미
- 적용요금
	- 통화 요금을 계산하는 조건을 의미
### 변경 캡슐화하기
- 변하지 않는 부분으로부터 변하는 부분을 분리하는 것
	- 변하는 부분의 공통점을 추상화 하는 것
	- 변하지 않는 부분은 추상화에 의존
### 협력 패턴 설계하기
- 변하지 않는 부분만을 이용해 객체 사이의 협력
- 협력 BasicRatePolicy가 calculateFee메시지 수신 ->전체 요금 계산 -> Call별로 FeeRule의 calculateFee 메시지 수신
	- BasicRatePolicy는 하나 이상의 FeeRule로 구성
- 전체 통화 시간을 각 규칙의 적용조건을 만족하는 구간 나누기
	- 적용조건 -> 정보전문가인 FeeCondition에게 할당
	- 단위요금 -> 요금을 계산하는 두번째 작업은 요금기준의 정보 전문가인 FeeRule이 담당
### 추상화 수준에서 협력 패턴 구현하기
- 적용조건 추상화 FeeCondition
- findTimeIntervals라는 단 하나의 오퍼레이션을 포함하는 간단한 인터페이스
- 이 오퍼레이션은 인자로 전달된 Call의 통화 기간 중에서 적용조건을 만족하는 기간을 구현 후 List에 담아 반환
- FeeRule은 단위요금과 적용조건을 저장하는 두 개의 인스턴스 변수로 구성
- 변하지 않는 추상화
	- 모두 조합하면 전체적인 협력 구조가 완성
### 구체적인 협력 구현하기
- FeeCondition 인터페이스를 실체화 하는 클래스에 따른 기본 정책의 종류
	- 시간대별 정책
		- TimeOfDayFeeCondition의 인스턴스는 협력 안에서 FeeCondition을 대체 할 수 있어야 함 -> FeeCondition의 인터페이스를 구현하는 서브타입으로 만들어야 함
		- findTimeIntercals
	- 요일별 정책
		- DayOfWeekFeeCondition의 인스턴스 -> DayOfWeek의 컬렉션을 변수로 포함
	- 구간별 정책
		- FeeCondition 인터페이스를 구현하는 DurationFeeCondition 클래스를 추가 후 findTimeIntercals 메서드를 오버라이딩
- 개념적 무결성(일관성)
	- 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것
### 협력 패턴에 맞추기
- 고정요금 방식의 FeeCondition을 추가하고 인자로 전달된 Call의 전체 통화 시간을 반환
- 받환받은 FeeRule은 단위 시간당 요금 정보를 이용해 전체 통화 기간에 대한 요금을 계산
- FixedFeeCondition클래스를 추가
- findTimeIntercals메서드의 반환 타입 List임에도 DateTimeIntercal인스턴스를 반환하는 것은 부조화지만 개녀적 무결성을 무너뜨리는 것보다는 나음
### 패턴을 찾아라
- 일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것
	- 협력에 참여하는 객체들의 역할과 책임을 결정
	- 결정된 협력이 코드의 구조를 결정
- 변경의 지속
	- 변경을 캡슐화 할 수 있는 적절한 추상화를 찾기
	- 추상화에 변하지 않는 공통적인 책임을 할당
- 구조변경을 캡슐화 하기 적합하지 않는 코드
	- 협력과 코드를 리팩토링
	- 적절한 역할과 책임을 찾으며 협력의 일관성을 추구하기
## 읽고 느낀점
- 캡슐화의 정의와 방법을 알 수 있었다.

