# 합성과 유연한 설계
## 00. 개요
- 상속(is-a관계) -> 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용
	- 부모와 자식클래스 사이의 의존성은 컴파일타임에 해결
	- 클래스 사이의 정적인 관계
- 합성(has-a관계) -> 전체를 표현하는 객체가 부분을 표현하는 개체를 포함해서 부분 객체의 코드를 재사용
	- 두 객체 사이의 의존성은 런타임에 해결
	- 객체 사이의 동적인 관계
## 01. 상속을 합성으로 변경하기
- 상속 남용 문제점
	- 불필요한 인터페이스 상속 문제
	- 메서드 오버라이딩의 오작용 문제
	- 부모 클래스와 자식 클래스의 동시 수정 문제
- 상속을 합성으로 바꾸는 방법 -> 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인터페이스를 자식 클래스의 인스턴스 변수로 선언
### 불필요한 인터페이스 상속문제
- Hashtable 클래스와 Properties 클래스 사이의 상속 관계를 합성으로 변경하기
### 메서드 오버라이딩의 오작용 문제
- InstrumentedHashSet도 합성으로 변경하기
- 포워딩 -> 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우 사용
- 포워딩 메서드 -> 동일한 메서드를 호출하기 위해 추가된 메서드
### 부모 클래스와 자식 클래스의 동시 수정 문제
- Playlist의 경우 합성으로 변경하더라도 PersonalPlaylist를 함께 수정해야 하지만 파급효과를 줄일 수 있음
- 몽키 패치 -> 현재 실행 중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것
## 02. 상속으로 인한 조합의 폭발적인 증가
- 상속으로 작은 기능들을 조합해서 더 큰 기능을 수행하는 개체를 만드는 경우의 문제점
	* 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 함
	* 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있음
### 기본 정책과 부가 정책 조합하기
- 부가 정책의 특징
	- 기본 정책의 계산 결과에 적용
	- 선택적으로 적용할 수 있음
	- 조합 가능
	- 부가 정책은 임의의 순서로 적용 가능
### 상속을 이용해서 기본 정책 구현하기
- 기본정책은 Phone 추상 클래스를 루트로 삼는 기존의 상속 계층을 그대로 이용
- RegularPhone과 심야 할인 요금제를 구현하는 NightDiscountPhone은 Phone 자식 클래스 구현
- RegularPhone과 NightDiscountPhone의 신스턴스만 단독으로 생성한다는 것은 부가 정책은 적용하지 않고 기본 정책만으로 요금 계산한다는 의미
### 기본 정책에 세금 정책 조합하기
- 일반 요금제에 세금 정책을 조합
- RegularPhone클래스를 상속받은 TaxableRegularPhone클래스 추가
- 추상 메서드와 훅 메서드
	- 개방-패쇄 원칙을 만족하는 설계는 부모 클래스에 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출
	- 추상메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드는 훅 메서드
### 기본 정책에 기본 요금 할인 정책 조합하기
- 일반 요금제와 기본 요금제 할인 정책을 조합
	- RegularPhone을 상속받는 RateDiscounttableRegluarPhone 클래스 추가
### 중복 코드의 덫에 걸리다
- 부가정책은 자유롭게 조합할 수 있어야 하고 적용되는 순서 역시 임의로 결정할 수 있어야 함
- TaxbaleRegularPhone을 상속받는 새로운 자식 클래스인 txableAndRateDiscountableRegularPhone 을 추가
- 클래스 폭발(조합의 폭발) -> 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가 해야 하는 경우
## 03. 합성 관계로 변경하기
- 상속 문제 -> 컴파일타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없음
- 합성 사용 -> 컴파일타임 관계를 런타임 관계로 변경함으로써 이 문제를 해결
### 기본 정책 합성하기
- 각 정책을 별도의 클래스로 구현
	- 핸드폰으로부터 요금 계산 방법 분리
	- 기본 정책과 부가 정책을 포괄하는 RatePolicy 인터페이스 추가
- 합성 사용
	- Phone와 연결되는 RatePolicy 인터페이스의 구현 클래스가 어떤 타입인지에 따라 요금을 계산하는 방식이 달라짐
### 부가 정책 적용하기
- RegularPolicy와 Phone사이에 세금 정책을 구현하는 TaxablePolicy 인스턴스를 연결
- 두가지 제약에 따른 부가 정책 구현
	- 부가 정책의 인스턴스는 어떤 종류의 정책과 합성될 수 있어야 함
	- 기본 정책과 부가 정책은 협력 안에서 동일한 '역할'을 수행해야 함
### 기본 정책과 부가 정책 합성하기
- 정책의 인스턴스를 생성한 후 의존성 주입을 통해 다른 정책의 인스턴스에 전달
### 새로운 정책 추가하기
- 상속기반 -> 한 설계에 새로운 부가 정책을 추가하기 위해서는 상속 계층에 불필요할 정도로 많은 클래스를 추가 해야 함
- 합성기반 -> 한 설계에의 고정 요금제가 필요하다면 고정 요금제를 구현한 클래스 하나만 추가한 후 원하는 방식으로 조합하면 됨
### 객체 합성이 클래스 상속보다 더 좋은 방법이다
- 합성
	- 코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법
	- 상속이 구현을 재사용 하는 데 비해 객체의 인터페이스를 재사용
## 04. 믹스인
- 믹스인 -> 객체를 생서할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법
	- 처음 도입은Flavors 언어 CLOS 
	- 스칼라 언어의 트레이트 CLOS 구현
### 기본 정책 구현하기
- BasicRatePolicy는 기본 정책에 속하는 전체 요금제 클래스들이 확장할 수 있도록 추상 클래스로 구현
### 트레이트로 부가 정책 구현하기
- 트레이트로 구현될 기능 대상 RagularPlicy와 NightDiscountPlicy
- 믹스인과 상속의 차이점
	- 상속 ->  정적, 부모 클래스와 자식 클래스의 고나계를 코드로 작성하는 시점에 고정시킴
	- 믹스인 -> 동적, 제약을 둘뿐 실제로 어떤 코드에 믹스인될 것인지를 결정하지 않음
### 부가 정책 트레이트 믹스인하기
- 트레이트 조합 -> 믹스인하려는 대상 클래스의 부모 클래스가 존재하는 경우 부모 클래스는 extends를 이용해 상속받고 트레이트는 with를 이용해 믹스인 해야 함
- 믹스인되기 전까지는 상속 계층 안에서 TaxablePolicy 트레이트의 위치가 결정되지 않는다는 것
	- 트레이트의 위치는 동적으로 변경
### 쌓을 수 있는 변경
- 정통적인 믹스인의 특징
	- 한 클래스의 메서드를 재사용하고 기능을 확장하기 위해 사용
	- 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가 할 수 있음(쌓을 수 있는 변경)
	- 대상 클래스의 자식 클래스처럼 사용될 용도
	- 믹스인은 추상 서브클래스
## 읽고 느낀점
- 변경에 용이한 것은 상속보다는 합성을 생각해야 한다
