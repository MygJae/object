# 의존성 관리하기
## 00. 개요
- 잘 설계된 객체지향
	- 책임의 초점이 명확하고 한가지 일만 잘하는 객체
	- 작고 응집도 높은 객체
	- 작은 객체들은 다른 객체사이의 협력을 요구함
- 협력적이면서도 유연한 객체를 만들기 위해 의존성을 관리하는 방법
## 01. 의존성 이해하기
### 변경과 의존성
- 의존성
	- 실행 시점 -> 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재
	- 구현시점 -> 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경
- UML과 의존성
	- UML -> 두 요소 사이의 관계로 의존 관계(이외 -> 실체화 관계, 연관 관계,  일반화/특수화 관계, 합성 관계, 집합 관계)
	- 의존성 -> 두 요소 사이에 변경에 의해 영향을 주고받는 힘의 역학관계가 존재 -> UML에서 정의하는 모든 관계
- ### 의존성 전이
- 의존성의 종류
	- 직접 의존성 -> 한 요소가 다른 요소에 직접 의존하는 경우
	- 간접 의존성 -> 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파된 경우
- ### 런타임 의존성과 컴파일타임 의존성
- 런타임 의존성 -> 객체 사이의 의존성
- 컴파일타임 의존성 -> 클래스 사이의 의존성
- 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연함 -> 재사용 용이
### 컨텍스트 독립성
- 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기 어려움
- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기 좋음
### 의존성 해결하기
- 컴파일 의존성은 구체적인 런타임 의존석으로 대체되어야 함
	- 객체를 생성하는 시점에서 생성자를 통해 의존성 해결
	- 객체 생성 후 setter 메서드를 통해 의존성 해결
	- 메서드 실행 시 인자를 이용해 의존성 해결
## 02. 유연한 설계
### 의존성과 결합도
- 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 함
- 의존성은 객체들의 협력을 가능하게 만드는 매개체
- 바람직한 의존성 -> 컨텍스트에 독립적인 의존성, 다양한 환경에 재사용 가능성, 느슨한 결합도, 약한 결합도
- 바람직하지 못한 의존성(결합도) -> 단단한 결합도,강한 결합도
### 자식이 결합을 낳는다
- 지식이 더 많이 알수록 
	- 더 많이 결합됨
	- 더 적은 컨텍스트에 재사용이 됨
- 협력에 대상에 대한 필요한 정보 외에 최대한 감춰야 함
- 해결방법은 추상화
### 추상화에 의존하라
- 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
- 아래로 갈수록 결합도 느슨함
	- 구체 클래스 의존성
	- 추상 클래스 의존성
	- 인터페이스 의존성
- 실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 낮아짐
### 명시적인 의존성
- 의존성 해결 방법
	- 생성자, setter 메서드, 메서드 인자
		- 추상 클래스를 상속받거나 인터페이스를 실체화한 구체 클래스 전달
	- 인스턴스 변수의 타입
		- 추상 클래스나 인터페이스로 정의
- 명시적 의존성
	- 모든 경우에 의존성은 퍼블릭 인터페이스에 노출
	- 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체 가능
- 숨겨진 의존성
	- 의존성이 퍼블릭 인터페이스에 표현되지 않음
	- 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 함
- 의존성은 다른 객체와의 협력을 가능하게 해주는데 의존성을 감추면 안됨
### new는 해롭다
- new가 해로운 이유
	- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 함
		- 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도 높아짐
	- new 연사자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지 알아야 함
		- new를 사용하면 클라이언트가 알아서 하는 지식의 양이 늘어나기 때문에 결합도 높아짐
#### 좋은 설계
- 사용과 생성의 책임을 분리
- 의존성을 생성자에 명시적으로 드러냄
- 구체 클래스가 아닌 추상 클래스에 의존
- 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트에서 시작
### 가끔은 생성해도 무방하다
- 클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우
	- 협력하는 기본 객체를 설정하고 싶은 경우
- 트레이드오프 결합도와 사용성
	- 구체 클래스에 의존하게 되더라도 클래스의 사용성이 더 중요하다면 결합도를 높이는 방향으로 코드를 작성 가능
- FACTORY -> 모든 결합도가 모이는 새로운 클래스를 추가함으로써 사용성과 유연성 다 잡을 수 있음
### 표준 클래스에 대한 의존은 해롭지 않다
- ArrayList 의 코드가 수정될 확률은 0에 가까워서 인스턴스를 직점 생성하더라도 문제가 안됨
- 클래스를 직접 생성하더라도 추상적인 타입으로 사용하는 것이 확장성 측면에서 유리함
- 의존성에 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러게는 것은 좋은 설계 습관
### 컨텍스트 확장하기
- 구현
	- 할인 혜택을 제공하지 않는 영화의 경우
	- 다수의 할인 정책을 중복해서 적용하는 영화를 처리하는 경우
### 조합 가능한 행동
- 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징
- 유연하고 재사용 가능한 설계
	- 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 쉽게 확장 가능
	- 객체가 어떻게 하는지 보다 객체들의 조합을 통해 무엇을 하는지 표현하는 클래스들로 구성
	- 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지 쉽게 파악 
	- 객체의 행동을 정의 가능
	- 작은 객체들의 행동을 조합함으로써 새로운 행동을 야기함
	- 객체들이 무엇을 하는지를 표현하는 설계
## 읽고 느낀점
- 유연한 설계를 위해서는 위의 기본 원칙이 존재하고, 그 사이에서 적절한 선택이 필요해 보인다

