# 상속과 코드 재사용성
## 00. 개요
- 객체지향에서 코드를 재사용하기 위해서는 새로운 코드를 추가하고 그 방법은 상속, 합성
## 01. 상속과 중복 코드
- 중복코드는 의도를 알기 힘들어 제거해야 함
### DRY(Dont's Repeat Yourself) 원칙
- 중복 코드는 변경을 방해하고 중복 여부를 판단하는 기준은 변경임
	- 요구사항이 변경됐을 때 두 코드를 수정하면 중복코드
- DRY 원칙
	- 한번, 단한번(Once and Only Once)
	- 단일 지점 제어(Single-Point Control)
### 중복과 변경
- 요구사항은 항상 변함
- 중복 코드가 제거되지 않고 수정할 수 있는 방법은 중복코드를 추가하는 것 뿐이므로 그로 인해 변경에 취약하고 버그발생이 높음
### 상속을 이용해서 중복 코드 제거하기
- 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용 하는 것
- 상속을 염두하고 설계되지 않은 클래스들은 상속을 이용해 재사용하기 어려움
- 상속은 결합도를 높히고 이 부분이 코드를 수정하기 어렵게 만듬
### 강하게 결합된 Phone과 NightlyDiscountPhone
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합함
	- super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거해야 함
- 취약한 기반 클래스 문제 -> 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상
	- 코드 재사용을 목적으로 상속을 사용할 때 발생하는 가장 대표적인 문제
## 02. 취약한 기반 클래스 문제
* 취약한 기반 클래스 문제 -> 캡슐화를 약화시키고 결합도를 높힘
### 불필요한 인터페이스 상속 문제
- 자바 초기 버전에서 상속의 잘못 사용한 사례
	- 프로퍼티스(java.util.Properties)
	- 스택(java.util.Stack) -> LIFO
- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있음
### 메서드 오버라이딩의 오작용 문제
- HashSet의 구현에 강하게 결합된 InstrumentedHashSet 클래스 -> HashSet의 내부에 저장된 요소의 수를 셀 수 있는 기능을 추가한 클래스로서 HashSet의 자식 클래스로 구현 됨
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있음
### 부모 클래스와 자식 클래스의 동시 수정 문제
* 자식 클래스가 부모 클래스의 메서드를 오버라딩하거나 불필요한 인터페이스를 상속받지 않았음에도 부모 클래스를 수정할 떄 자식 클래스를 함께 수정해야 할 수 있음
* 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없음
## 03. Phone 다시 살펴보기
- 상속으로 인한 피해를 최소화 할 수 있는 방법은 추상화
### 추상화에 의존하자
- 자식 클래스가 부모 클래스의 구현이 아닌 두 클래스 모두 추상화에 의존하여 만드는 것
- 코드 중복을 제거하기 위해 상속을 도입할 때 두 가지 원칙
	- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출
		- 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있음
	- 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올리기
		- 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 좋음
### 차이를 메서드로 추출하라
- 중복 코드 안에서 차이점을 별도의 메서드로 추출
	- 변하는 것으로부터 변하지 않는 것을 분리
	- 변하는 부분을 찾고 이를 캡슐화 하기
### 중복 코드를 부모 클래스로 올려라
- 부모 클래스를 추가
	- 모든 클래스들이 추상화에 의존하게 만들기
	- 자식 클래스들 사이의 공통점을 부모 클래스로 옮기기
### 추상화가 핵심이다
- 추상화의 장점
	- 단일 책임 원칙(높은 응집도)
	- 낮은 결합도
	- 의존성 역전 원칙
	- 개방-폐쇄 원칙
- 차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동
### 의도를 드러내는 이름 선택하기
- 명시적으로 전달되야 함
	- AbstractPhon -> Phone, Phone -> RegularPhone
- 좋은 상속 계층을 구성하기 위해서는 상속 계층 안에 속한 클래스들이 구현이 아닌 추상화에 의존
### 세금 추가하기
- 핵심로직
	- 중복을 막기
	- 한곳에 모아놓고 캡슐화
	- 공통적인 부분 최대한 추상화
- 상속으로 인한 클래스 사이의 결합을 피할 수 없음
	- 변경하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전체에 걸쳐  부작용이 퍼지지 않게 막는 것
	- 메서드 구현에 대한 결합은 추상 메서드를 추가함으로써 어느정도 완화할 수 있음
	- 인스턴스 변수에 대한 잠재적인 결합을 제거할 수 있는 방법은 없음
## 04. 차이에 의한 프로그래밍
- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
## 읽고 느낀점
- 공통적인 뼈대에 필요한 살을 바꿔서 변경에 용이하게 만드는게 중요한 이유는 요구사항은 항상 있고 그로 인해 변경에 용이해야 하고 그것이 객체지향 프로그래밍을 하는 이유 같다


